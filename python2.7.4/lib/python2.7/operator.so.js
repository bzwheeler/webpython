// Note: Some Emscripten settings will significantly limit the speed of the generated code.
// Note: Some Emscripten settings may limit the speed of the generated code.
// Capture the output of this into a variable, if you want
(function(FUNCTION_TABLE_OFFSET, globalScope) {
  var Module = {};
  var args = [];
  Module.arguments = [];
// === Auto-generated preamble library stuff ===
//========================================
// Runtime essentials
//========================================
function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.pop();
    var func = callback.func;
    if (typeof func === 'number') {
      func = FUNCTION_TABLE[func];
    }
    func(callback.arg === undefined ? null : callback.arg);
  }
}
var __ATINIT__ = []; // functions called during startup
function initRuntime() {
  callRuntimeCallbacks(__ATINIT__);
}
// === Body ===
var _operator_methods;
var _operator_doc;
var _methodcaller_type;
var _methodcaller_doc;
var _itemgetter_type;
var _itemgetter_doc;
var _attrgetter_type;
var _attrgetter_doc;
var __str99;
var __str98;
var __str97;
var __str96;
var __str95;
var __str94;
var __str93;
var __str92;
var __str91;
var __str90;
var __str9;
var __str89;
var __str88;
var __str87;
var __str86;
var __str85;
var __str84;
var __str83;
var __str82;
var __str81;
var __str80;
var __str8;
var __str79;
var __str78;
var __str77;
var __str76;
var __str75;
var __str74;
var __str73;
var __str72;
var __str71;
var __str70;
var __str7;
var __str69;
var __str68;
var __str67;
var __str66;
var __str65;
var __str64;
var __str63;
var __str62;
var __str61;
var __str60;
var __str6;
var __str59;
var __str58;
var __str57;
var __str56;
var __str55;
var __str54;
var __str53;
var __str52;
var __str51;
var __str50;
var __str5;
var __str49;
var __str48;
var __str47;
var __str46;
var __str45;
var __str44;
var __str43;
var __str42;
var __str41;
var __str40;
var __str4;
var __str39;
var __str38;
var __str37;
var __str36;
var __str35;
var __str34;
var __str33;
var __str32;
var __str31;
var __str30;
var __str3;
var __str29;
var __str28;
var __str27;
var __str26;
var __str25;
var __str24;
var __str23;
var __str228;
var __str227;
var __str226;
var __str225;
var __str224;
var __str223;
var __str222;
var __str221;
var __str220;
var __str22;
var __str219;
var __str218;
var __str217;
var __str216;
var __str215;
var __str214;
var __str213;
var __str212;
var __str211;
var __str210;
var __str21;
var __str209;
var __str208;
var __str207;
var __str206;
var __str205;
var __str204;
var __str203;
var __str202;
var __str201;
var __str200;
var __str20;
var __str2;
var __str199;
var __str198;
var __str197;
var __str196;
var __str195;
var __str194;
var __str193;
var __str192;
var __str191;
var __str190;
var __str19;
var __str189;
var __str188;
var __str187;
var __str186;
var __str185;
var __str184;
var __str183;
var __str182;
var __str181;
var __str180;
var __str18;
var __str179;
var __str178;
var __str177;
var __str176;
var __str175;
var __str174;
var __str173;
var __str172;
var __str171;
var __str170;
var __str17;
var __str169;
var __str168;
var __str167;
var __str166;
var __str165;
var __str164;
var __str163;
var __str162;
var __str161;
var __str160;
var __str16;
var __str159;
var __str158;
var __str157;
var __str156;
var __str155;
var __str154;
var __str153;
var __str152;
var __str151;
var __str150;
var __str15;
var __str149;
var __str148;
var __str147;
var __str146;
var __str145;
var __str144;
var __str143;
var __str142;
var __str141;
var __str140;
var __str14;
var __str139;
var __str138;
var __str137;
var __str136;
var __str135;
var __str134;
var __str133;
var __str132;
var __str131;
var __str130;
var __str13;
var __str129;
var __str128;
var __str127;
var __str126;
var __str125;
var __str124;
var __str123;
var __str122;
var __str121;
var __str120;
var __str12;
var __str119;
var __str118;
var __str117;
var __str116;
var __str115;
var __str114;
var __str113;
var __str112;
var __str111;
var __str110;
var __str11;
var __str109;
var __str108;
var __str107;
var __str106;
var __str105;
var __str104;
var __str103;
var __str102;
var __str101;
var __str100;
var __str10;
var __str1;
var __str;
var ___func___itemgetter_call;
var ___func___attrgetter_call;
_operator_methods=allocate([0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_NORMAL);
_operator_doc=allocate([79,112,101,114,97,116,111,114,32,105,110,116,101,114,102,97,99,101,46,10,10,84,104,105,115,32,109,111,100,117,108,101,32,101,120,112,111,114,116,115,32,97,32,115,101,116,32,111,102,32,102,117,110,99,116,105,111,110,115,32,105,109,112,108,101,109,101,110,116,101,100,32,105,110,32,67,32,99,111,114,114,101,115,112,111,110,100,105,110,103,10,116,111,32,116,104,101,32,105,110,116,114,105,110,115,105,99,32,111,112,101,114,97,116,111,114,115,32,111,102,32,80,121,116,104,111,110,46,32,32,70,111,114,32,101,120,97,109,112,108,101,44,32,111,112,101,114,97,116,111,114,46,97,100,100,40,120,44,32,121,41,10,105,115,32,101,113,117,105,118,97,108,101,110,116,32,116,111,32,116,104,101,32,101,120,112,114,101,115,115,105,111,110,32,120,43,121,46,32,32,84,104,101,32,102,117,110,99,116,105,111,110,32,110,97,109,101,115,32,97,114,101,32,116,104,111,115,101,10,117,115,101,100,32,102,111,114,32,115,112,101,99,105,97,108,32,109,101,116,104,111,100,115,59,32,118,97,114,105,97,110,116,115,32,119,105,116,104,111,117,116,32,108,101,97,100,105,110,103,32,97,110,100,32,116,114,97,105,108,105,110,103,10,39,95,95,39,32,97,114,101,32,97,108,115,111,32,112,114,111,118,105,100,101,100,32,102,111,114,32,99,111,110,118,101,110,105,101,110,99,101,46,0,0,0,0], "i8", ALLOC_NORMAL);
_methodcaller_type=allocate([1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,235,65,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_NORMAL);
_methodcaller_doc=allocate([109,101,116,104,111,100,99,97,108,108,101,114,40,110,97,109,101,44,32,46,46,46,41,32,45,45,62,32,109,101,116,104,111,100,99,97,108,108,101,114,32,111,98,106,101,99,116,10,10,82,101,116,117,114,110,32,97,32,99,97,108,108,97,98,108,101,32,111,98,106,101,99,116,32,116,104,97,116,32,99,97,108,108,115,32,116,104,101,32,103,105,118,101,110,32,109,101,116,104,111,100,32,111,110,32,105,116,115,32,111,112,101,114,97,110,100,46,10,65,102,116,101,114,44,32,102,32,61,32,109,101,116,104,111,100,99,97,108,108,101,114,40,39,110,97,109,101,39,41,44,32,116,104,101,32,99,97,108,108,32,102,40,114,41,32,114,101,116,117,114,110,115,32,114,46,110,97,109,101,40,41,46,10,65,102,116,101,114,44,32,103,32,61,32,109,101,116,104,111,100,99,97,108,108,101,114,40,39,110,97,109,101,39,44,32,39,100,97,116,101,39,44,32,102,111,111,61,49,41,44,32,116,104,101,32,99,97,108,108,32,103,40,114,41,32,114,101,116,117,114,110,115,10,114,46,110,97,109,101,40,39,100,97,116,101,39,44,32,102,111,111,61,49,41,46,0], "i8", ALLOC_NORMAL);
_itemgetter_type=allocate([1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,235,65,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_NORMAL);
_itemgetter_doc=allocate([105,116,101,109,103,101,116,116,101,114,40,105,116,101,109,44,32,46,46,46,41,32,45,45,62,32,105,116,101,109,103,101,116,116,101,114,32,111,98,106,101,99,116,10,10,82,101,116,117,114,110,32,97,32,99,97,108,108,97,98,108,101,32,111,98,106,101,99,116,32,116,104,97,116,32,102,101,116,99,104,101,115,32,116,104,101,32,103,105,118,101,110,32,105,116,101,109,40,115,41,32,102,114,111,109,32,105,116,115,32,111,112,101,114,97,110,100,46,10,65,102,116,101,114,44,32,102,61,105,116,101,109,103,101,116,116,101,114,40,50,41,44,32,116,104,101,32,99,97,108,108,32,102,40,114,41,32,114,101,116,117,114,110,115,32,114,91,50,93,46,10,65,102,116,101,114,44,32,103,61,105,116,101,109,103,101,116,116,101,114,40,50,44,53,44,51,41,44,32,116,104,101,32,99,97,108,108,32,103,40,114,41,32,114,101,116,117,114,110,115,32,40,114,91,50,93,44,32,114,91,53,93,44,32,114,91,51,93,41,0], "i8", ALLOC_NORMAL);
_attrgetter_type=allocate([1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,235,65,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_NORMAL);
_attrgetter_doc=allocate([97,116,116,114,103,101,116,116,101,114,40,97,116,116,114,44,32,46,46,46,41,32,45,45,62,32,97,116,116,114,103,101,116,116,101,114,32,111,98,106,101,99,116,10,10,82,101,116,117,114,110,32,97,32,99,97,108,108,97,98,108,101,32,111,98,106,101,99,116,32,116,104,97,116,32,102,101,116,99,104,101,115,32,116,104,101,32,103,105,118,101,110,32,97,116,116,114,105,98,117,116,101,40,115,41,32,102,114,111,109,32,105,116,115,32,111,112,101,114,97,110,100,46,10,65,102,116,101,114,44,32,102,61,97,116,116,114,103,101,116,116,101,114,40,39,110,97,109,101,39,41,44,32,116,104,101,32,99,97,108,108,32,102,40,114,41,32,114,101,116,117,114,110,115,32,114,46,110,97,109,101,46,10,65,102,116,101,114,44,32,103,61,97,116,116,114,103,101,116,116,101,114,40,39,110,97,109,101,39,44,32,39,100,97,116,101,39,41,44,32,116,104,101,32,99,97,108,108,32,103,40,114,41,32,114,101,116,117,114,110,115,32,40,114,46,110,97,109,101,44,32,114,46,100,97,116,101,41,46,10,65,102,116,101,114,44,32,104,61,97,116,116,114,103,101,116,116,101,114,40,39,110,97,109,101,46,102,105,114,115,116,39,44,32,39,110,97,109,101,46,108,97,115,116,39,41,44,32,116,104,101,32,99,97,108,108,32,104,40,114,41,32,114,101,116,117,114,110,115,10,40,114,46,110,97,109,101,46,102,105,114,115,116,44,32,114,46,110,97,109,101,46,108,97,115,116,41,46,0,0], "i8", ALLOC_NORMAL);
__str99=allocate([105,115,117,98,0,0,0,0], "i8", ALLOC_NORMAL);
__str98=allocate([95,95,105,97,100,100,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str97=allocate([97,32,61,32,105,97,100,100,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,43,61,32,98,46,0,0,0], "i8", ALLOC_NORMAL);
__str96=allocate([105,97,100,100,0,0,0,0], "i8", ALLOC_NORMAL);
__str95=allocate([95,95,111,114,95,95,0,0], "i8", ALLOC_NORMAL);
__str94=allocate([111,114,95,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,124,32,98,46,0], "i8", ALLOC_NORMAL);
__str93=allocate([111,114,95,0], "i8", ALLOC_NORMAL);
__str92=allocate([95,95,120,111,114,95,95,0], "i8", ALLOC_NORMAL);
__str91=allocate([120,111,114,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,94,32,98,46,0], "i8", ALLOC_NORMAL);
__str90=allocate([120,111,114,0], "i8", ALLOC_NORMAL);
__str9=allocate([80,121,84,117,112,108,101,95,67,104,101,99,107,40,97,103,45,62,97,116,116,114,41,0], "i8", ALLOC_NORMAL);
__str89=allocate([95,95,97,110,100,95,95,0], "i8", ALLOC_NORMAL);
__str88=allocate([97,110,100,95,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,38,32,98,46,0,0,0,0], "i8", ALLOC_NORMAL);
__str87=allocate([97,110,100,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str86=allocate([95,95,110,111,116,95,95,0], "i8", ALLOC_NORMAL);
__str85=allocate([110,111,116,95,40,97,41,32,45,45,32,83,97,109,101,32,97,115,32,110,111,116,32,97,46,0,0,0], "i8", ALLOC_NORMAL);
__str84=allocate([110,111,116,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str83=allocate([95,95,114,115,104,105,102,116,95,95,0,0], "i8", ALLOC_NORMAL);
__str82=allocate([114,115,104,105,102,116,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,62,62,32,98,46,0], "i8", ALLOC_NORMAL);
__str81=allocate([114,115,104,105,102,116,0,0], "i8", ALLOC_NORMAL);
__str80=allocate([95,95,108,115,104,105,102,116,95,95,0,0], "i8", ALLOC_NORMAL);
__str8=allocate([46,46,47,77,111,100,117,108,101,115,47,111,112,101,114,97,116,111,114,46,99,0,0,0], "i8", ALLOC_NORMAL);
__str79=allocate([108,115,104,105,102,116,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,60,60,32,98,46,0], "i8", ALLOC_NORMAL);
__str78=allocate([108,115,104,105,102,116,0,0], "i8", ALLOC_NORMAL);
__str77=allocate([95,95,105,110,118,101,114,116,95,95,0,0], "i8", ALLOC_NORMAL);
__str76=allocate([105,110,118,101,114,116,40,97,41,32,45,45,32,83,97,109,101,32,97,115,32,126,97,46,0,0,0,0], "i8", ALLOC_NORMAL);
__str75=allocate([105,110,118,101,114,116,0,0], "i8", ALLOC_NORMAL);
__str74=allocate([95,95,105,110,118,95,95,0], "i8", ALLOC_NORMAL);
__str73=allocate([105,110,118,40,97,41,32,45,45,32,83,97,109,101,32,97,115,32,126,97,46,0,0,0], "i8", ALLOC_NORMAL);
__str72=allocate([105,110,118,0], "i8", ALLOC_NORMAL);
__str71=allocate([95,95,97,98,115,95,95,0], "i8", ALLOC_NORMAL);
__str70=allocate([97,98,115,40,97,41,32,45,45,32,83,97,109,101,32,97,115,32,97,98,115,40,97,41,46,0,0,0], "i8", ALLOC_NORMAL);
__str7=allocate([97,116,116,114,103,101,116,116,101,114,40,41,0,0,0,0], "i8", ALLOC_NORMAL);
__str69=allocate([97,98,115,0], "i8", ALLOC_NORMAL);
__str68=allocate([95,95,112,111,115,95,95,0], "i8", ALLOC_NORMAL);
__str67=allocate([112,111,115,40,97,41,32,45,45,32,83,97,109,101,32,97,115,32,43,97,46,0,0,0], "i8", ALLOC_NORMAL);
__str66=allocate([112,111,115,0], "i8", ALLOC_NORMAL);
__str65=allocate([95,95,110,101,103,95,95,0], "i8", ALLOC_NORMAL);
__str64=allocate([110,101,103,40,97,41,32,45,45,32,83,97,109,101,32,97,115,32,45,97,46,0,0,0], "i8", ALLOC_NORMAL);
__str63=allocate([110,101,103,0], "i8", ALLOC_NORMAL);
__str62=allocate([95,95,109,111,100,95,95,0], "i8", ALLOC_NORMAL);
__str61=allocate([109,111,100,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,37,32,98,46,0], "i8", ALLOC_NORMAL);
__str60=allocate([109,111,100,0], "i8", ALLOC_NORMAL);
__str6=allocate([111,112,101,114,97,116,111,114,46,97,116,116,114,103,101,116,116,101,114,0], "i8", ALLOC_NORMAL);
__str59=allocate([95,95,116,114,117,101,100,105,118,95,95,0], "i8", ALLOC_NORMAL);
__str58=allocate([116,114,117,101,100,105,118,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,47,32,98,32,119,104,101,110,32,95,95,102,117,116,117,114,101,95,95,46,100,105,118,105,115,105,111,110,32,105,115,32,105,110,32,101,102,102,101,99,116,46,0,0,0], "i8", ALLOC_NORMAL);
__str57=allocate([116,114,117,101,100,105,118,0], "i8", ALLOC_NORMAL);
__str56=allocate([95,95,102,108,111,111,114,100,105,118,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str55=allocate([102,108,111,111,114,100,105,118,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,47,47,32,98,46,0,0,0], "i8", ALLOC_NORMAL);
__str54=allocate([102,108,111,111,114,100,105,118,0,0,0,0], "i8", ALLOC_NORMAL);
__str53=allocate([95,95,100,105,118,95,95,0], "i8", ALLOC_NORMAL);
__str52=allocate([100,105,118,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,47,32,98,32,119,104,101,110,32,95,95,102,117,116,117,114,101,95,95,46,100,105,118,105,115,105,111,110,32,105,115,32,110,111,116,32,105,110,32,101,102,102,101,99,116,46,0,0,0], "i8", ALLOC_NORMAL);
__str51=allocate([100,105,118,0], "i8", ALLOC_NORMAL);
__str50=allocate([95,95,109,117,108,95,95,0], "i8", ALLOC_NORMAL);
__str5=allocate([109,101,116,104,111,100,99,97,108,108,101,114,32,110,101,101,100,115,32,97,116,32,108,101,97,115,116,32,111,110,101,32,97,114,103,117,109,101,110,116,44,32,116,104,101,32,109,101,116,104,111,100,32,110,97,109,101,0,0,0], "i8", ALLOC_NORMAL);
__str49=allocate([109,117,108,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,42,32,98,46,0], "i8", ALLOC_NORMAL);
__str48=allocate([109,117,108,0], "i8", ALLOC_NORMAL);
__str47=allocate([95,95,115,117,98,95,95,0], "i8", ALLOC_NORMAL);
__str46=allocate([115,117,98,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,45,32,98,46,0], "i8", ALLOC_NORMAL);
__str45=allocate([115,117,98,0], "i8", ALLOC_NORMAL);
__str44=allocate([95,95,97,100,100,95,95,0], "i8", ALLOC_NORMAL);
__str43=allocate([97,100,100,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,43,32,98,46,0], "i8", ALLOC_NORMAL);
__str42=allocate([97,100,100,0], "i8", ALLOC_NORMAL);
__str41=allocate([95,95,105,110,100,101,120,95,95,0,0,0], "i8", ALLOC_NORMAL);
__str40=allocate([105,110,100,101,120,40,97,41,32,45,45,32,83,97,109,101,32,97,115,32,97,46,95,95,105,110,100,101,120,95,95,40,41,0,0,0], "i8", ALLOC_NORMAL);
__str4=allocate([111,112,101,114,97,116,111,114,46,109,101,116,104,111,100,99,97,108,108,101,114,0,0,0], "i8", ALLOC_NORMAL);
__str39=allocate([105,110,100,101,120,0,0,0], "i8", ALLOC_NORMAL);
__str38=allocate([105,115,95,110,111,116,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,105,115,32,110,111,116,32,98,46,0], "i8", ALLOC_NORMAL);
__str37=allocate([105,115,95,110,111,116,0,0], "i8", ALLOC_NORMAL);
__str36=allocate([105,115,95,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,105,115,32,98,46,0,0,0,0], "i8", ALLOC_NORMAL);
__str35=allocate([105,115,95,0], "i8", ALLOC_NORMAL);
__str34=allocate([105,115,77,97,112,112,105,110,103,84,121,112,101,40,97,41,32,45,45,32,82,101,116,117,114,110,32,84,114,117,101,32,105,102,32,97,32,104,97,115,32,97,32,109,97,112,112,105,110,103,32,116,121,112,101,44,32,70,97,108,115,101,32,111,116,104,101,114,119,105,115,101,46,0,0,0], "i8", ALLOC_NORMAL);
__str33=allocate([105,115,77,97,112,112,105,110,103,84,121,112,101,0,0,0], "i8", ALLOC_NORMAL);
__str32=allocate([99,111,117,110,116,79,102,40,97,44,32,98,41,32,45,45,32,82,101,116,117,114,110,32,116,104,101,32,110,117,109,98,101,114,32,111,102,32,116,105,109,101,115,32,98,32,111,99,99,117,114,115,32,105,110,32,97,46,0,0], "i8", ALLOC_NORMAL);
__str31=allocate([99,111,117,110,116,79,102,0], "i8", ALLOC_NORMAL);
__str30=allocate([105,110,100,101,120,79,102,40,97,44,32,98,41,32,45,45,32,82,101,116,117,114,110,32,116,104,101,32,102,105,114,115,116,32,105,110,100,101,120,32,111,102,32,98,32,105,110,32,97,46,0,0], "i8", ALLOC_NORMAL);
__str3=allocate([109,101,116,104,111,100,99,97,108,108,101,114,0,0,0,0], "i8", ALLOC_NORMAL);
__str29=allocate([105,110,100,101,120,79,102,0], "i8", ALLOC_NORMAL);
__str28=allocate([115,101,113,117,101,110,99,101,73,110,99,108,117,100,101,115,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,98,32,105,110,32,97,32,40,110,111,116,101,32,114,101,118,101,114,115,101,100,32,111,112,101,114,97,110,100,115,59,32,100,101,112,114,101,99,97,116,101,100,41,46,0,0], "i8", ALLOC_NORMAL);
__str27=allocate([115,101,113,117,101,110,99,101,73,110,99,108,117,100,101,115,0,0,0,0], "i8", ALLOC_NORMAL);
__str26=allocate([95,95,99,111,110,116,97,105,110,115,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str25=allocate([99,111,110,116,97,105,110,115,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,98,32,105,110,32,97,32,40,110,111,116,101,32,114,101,118,101,114,115,101,100,32,111,112,101,114,97,110,100,115,41,46,0,0], "i8", ALLOC_NORMAL);
__str24=allocate([99,111,110,116,97,105,110,115,0,0,0,0], "i8", ALLOC_NORMAL);
__str23=allocate([116,114,117,116,104,40,97,41,32,45,45,32,82,101,116,117,114,110,32,84,114,117,101,32,105,102,32,97,32,105,115,32,116,114,117,101,44,32,70,97,108,115,101,32,111,116,104,101,114,119,105,115,101,46,0,0], "i8", ALLOC_NORMAL);
__str228=allocate([111,112,101,114,97,116,111,114,46,105,115,67,97,108,108,97,98,108,101,40,41,32,105,115,32,110,111,116,32,115,117,112,112,111,114,116,101,100,32,105,110,32,51,46,120,46,32,85,115,101,32,104,97,115,97,116,116,114,40,111,98,106,44,32,39,95,95,99,97,108,108,95,95,39,41,46,0,0,0,0], "i8", ALLOC_NORMAL);
__str227=allocate([111,112,95,99,111,110,116,97,105,110,115,0], "i8", ALLOC_NORMAL);
__str226=allocate([111,112,101,114,97,116,111,114,46,115,101,113,117,101,110,99,101,73,110,99,108,117,100,101,115,40,41,32,105,115,32,110,111,116,32,115,117,112,112,111,114,116,101,100,32,105,110,32,51,46,120,46,32,85,115,101,32,111,112,101,114,97,116,111,114,46,99,111,110,116,97,105,110,115,40,41,46,0,0,0], "i8", ALLOC_NORMAL);
__str225=allocate([111,112,95,97,100,100,0,0], "i8", ALLOC_NORMAL);
__str224=allocate([111,112,95,115,117,98,0,0], "i8", ALLOC_NORMAL);
__str223=allocate([111,112,95,109,117,108,0,0], "i8", ALLOC_NORMAL);
__str222=allocate([111,112,95,100,105,118,0,0], "i8", ALLOC_NORMAL);
__str221=allocate([111,112,95,102,108,111,111,114,100,105,118,0], "i8", ALLOC_NORMAL);
__str220=allocate([111,112,95,116,114,117,101,100,105,118,0,0], "i8", ALLOC_NORMAL);
__str22=allocate([116,114,117,116,104,0,0,0], "i8", ALLOC_NORMAL);
__str219=allocate([111,112,95,109,111,100,0,0], "i8", ALLOC_NORMAL);
__str218=allocate([111,112,95,108,115,104,105,102,116,0,0,0], "i8", ALLOC_NORMAL);
__str217=allocate([111,112,95,114,115,104,105,102,116,0,0,0], "i8", ALLOC_NORMAL);
__str216=allocate([111,112,95,97,110,100,95,0], "i8", ALLOC_NORMAL);
__str215=allocate([111,112,95,120,111,114,0,0], "i8", ALLOC_NORMAL);
__str214=allocate([111,112,95,111,114,95,0,0], "i8", ALLOC_NORMAL);
__str213=allocate([111,112,95,105,97,100,100,0], "i8", ALLOC_NORMAL);
__str212=allocate([111,112,95,105,115,117,98,0], "i8", ALLOC_NORMAL);
__str211=allocate([111,112,95,105,109,117,108,0], "i8", ALLOC_NORMAL);
__str210=allocate([111,112,95,105,100,105,118,0], "i8", ALLOC_NORMAL);
__str21=allocate([105,115,83,101,113,117,101,110,99,101,84,121,112,101,40,97,41,32,45,45,32,82,101,116,117,114,110,32,84,114,117,101,32,105,102,32,97,32,104,97,115,32,97,32,115,101,113,117,101,110,99,101,32,116,121,112,101,44,32,70,97,108,115,101,32,111,116,104,101,114,119,105,115,101,46,0], "i8", ALLOC_NORMAL);
__str209=allocate([111,112,95,105,102,108,111,111,114,100,105,118,0,0,0,0], "i8", ALLOC_NORMAL);
__str208=allocate([111,112,95,105,116,114,117,101,100,105,118,0], "i8", ALLOC_NORMAL);
__str207=allocate([111,112,95,105,109,111,100,0], "i8", ALLOC_NORMAL);
__str206=allocate([111,112,95,105,108,115,104,105,102,116,0,0], "i8", ALLOC_NORMAL);
__str205=allocate([111,112,95,105,114,115,104,105,102,116,0,0], "i8", ALLOC_NORMAL);
__str204=allocate([111,112,95,105,97,110,100,0], "i8", ALLOC_NORMAL);
__str203=allocate([111,112,95,105,120,111,114,0], "i8", ALLOC_NORMAL);
__str202=allocate([111,112,95,105,111,114,0,0], "i8", ALLOC_NORMAL);
__str201=allocate([111,112,95,99,111,110,99,97,116,0,0,0], "i8", ALLOC_NORMAL);
__str200=allocate([79,105,58,111,112,95,114,101,112,101,97,116,0,0,0,0], "i8", ALLOC_NORMAL);
__str20=allocate([105,115,83,101,113,117,101,110,99,101,84,121,112,101,0,0], "i8", ALLOC_NORMAL);
__str2=allocate([97,116,116,114,103,101,116,116,101,114,0,0], "i8", ALLOC_NORMAL);
__str199=allocate([111,112,95,105,99,111,110,99,97,116,0,0], "i8", ALLOC_NORMAL);
__str198=allocate([79,105,58,111,112,95,105,114,101,112,101,97,116,0,0,0], "i8", ALLOC_NORMAL);
__str197=allocate([111,112,95,103,101,116,105,116,101,109,0,0], "i8", ALLOC_NORMAL);
__str196=allocate([111,112,95,115,101,116,105,116,101,109,0,0], "i8", ALLOC_NORMAL);
__str195=allocate([111,112,95,100,101,108,105,116,101,109,0,0], "i8", ALLOC_NORMAL);
__str194=allocate([79,110,110,58,103,101,116,115,108,105,99,101,0,0,0,0], "i8", ALLOC_NORMAL);
__str193=allocate([79,110,110,79,58,115,101,116,115,108,105,99,101,0,0,0], "i8", ALLOC_NORMAL);
__str192=allocate([79,110,110,58,100,101,108,115,108,105,99,101,0,0,0,0], "i8", ALLOC_NORMAL);
__str191=allocate([111,112,95,108,116,0,0,0], "i8", ALLOC_NORMAL);
__str190=allocate([111,112,95,108,101,0,0,0], "i8", ALLOC_NORMAL);
__str19=allocate([105,115,78,117,109,98,101,114,84,121,112,101,40,97,41,32,45,45,32,82,101,116,117,114,110,32,84,114,117,101,32,105,102,32,97,32,104,97,115,32,97,32,110,117,109,101,114,105,99,32,116,121,112,101,44,32,70,97,108,115,101,32,111,116,104,101,114,119,105,115,101,46,0,0,0,0], "i8", ALLOC_NORMAL);
__str189=allocate([111,112,95,101,113,0,0,0], "i8", ALLOC_NORMAL);
__str188=allocate([111,112,95,110,101,0,0,0], "i8", ALLOC_NORMAL);
__str187=allocate([111,112,95,103,116,0,0,0], "i8", ALLOC_NORMAL);
__str186=allocate([111,112,95,103,101,0,0,0], "i8", ALLOC_NORMAL);
__str185=allocate([95,95,103,101,95,95,0,0], "i8", ALLOC_NORMAL);
__str184=allocate([103,101,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,62,61,98,46,0,0,0], "i8", ALLOC_NORMAL);
__str183=allocate([103,101,0,0], "i8", ALLOC_NORMAL);
__str182=allocate([95,95,103,116,95,95,0,0], "i8", ALLOC_NORMAL);
__str181=allocate([103,116,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,62,98,46,0,0,0,0], "i8", ALLOC_NORMAL);
__str180=allocate([103,116,0,0], "i8", ALLOC_NORMAL);
__str18=allocate([105,115,78,117,109,98,101,114,84,121,112,101,0,0,0,0], "i8", ALLOC_NORMAL);
__str179=allocate([95,95,110,101,95,95,0,0], "i8", ALLOC_NORMAL);
__str178=allocate([110,101,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,33,61,98,46,0,0,0], "i8", ALLOC_NORMAL);
__str177=allocate([110,101,0,0], "i8", ALLOC_NORMAL);
__str176=allocate([95,95,101,113,95,95,0,0], "i8", ALLOC_NORMAL);
__str175=allocate([101,113,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,61,61,98,46,0,0,0], "i8", ALLOC_NORMAL);
__str174=allocate([101,113,0,0], "i8", ALLOC_NORMAL);
__str173=allocate([95,95,108,101,95,95,0,0], "i8", ALLOC_NORMAL);
__str172=allocate([108,101,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,60,61,98,46,0,0,0], "i8", ALLOC_NORMAL);
__str171=allocate([108,101,0,0], "i8", ALLOC_NORMAL);
__str170=allocate([95,95,108,116,95,95,0,0], "i8", ALLOC_NORMAL);
__str17=allocate([105,115,67,97,108,108,97,98,108,101,40,97,41,32,45,45,32,83,97,109,101,32,97,115,32,99,97,108,108,97,98,108,101,40,97,41,46,0,0,0], "i8", ALLOC_NORMAL);
__str169=allocate([108,116,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,60,98,46,0,0,0,0], "i8", ALLOC_NORMAL);
__str168=allocate([108,116,0,0], "i8", ALLOC_NORMAL);
__str167=allocate([95,95,100,101,108,115,108,105,99,101,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str166=allocate([100,101,108,115,108,105,99,101,40,97,44,32,98,44,32,99,41,32,45,45,32,83,97,109,101,32,97,115,32,100,101,108,32,97,91,98,58,99,93,46,0,0,0,0], "i8", ALLOC_NORMAL);
__str165=allocate([100,101,108,115,108,105,99,101,0,0,0,0], "i8", ALLOC_NORMAL);
__str164=allocate([95,95,115,101,116,115,108,105,99,101,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str163=allocate([115,101,116,115,108,105,99,101,40,97,44,32,98,44,32,99,44,32,100,41,32,45,45,32,83,97,109,101,32,97,115,32,97,91,98,58,99,93,32,61,32,100,46,0], "i8", ALLOC_NORMAL);
__str162=allocate([115,101,116,115,108,105,99,101,0,0,0,0], "i8", ALLOC_NORMAL);
__str161=allocate([95,95,103,101,116,115,108,105,99,101,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str160=allocate([103,101,116,115,108,105,99,101,40,97,44,32,98,44,32,99,41,32,45,45,32,83,97,109,101,32,97,115,32,97,91,98,58,99,93,46,0,0,0,0], "i8", ALLOC_NORMAL);
__str16=allocate([105,115,67,97,108,108,97,98,108,101,0,0], "i8", ALLOC_NORMAL);
__str159=allocate([103,101,116,115,108,105,99,101,0,0,0,0], "i8", ALLOC_NORMAL);
__str158=allocate([95,95,105,112,111,119,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str157=allocate([97,32,61,32,105,112,111,119,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,42,42,61,32,98,46,0,0], "i8", ALLOC_NORMAL);
__str156=allocate([105,112,111,119,0,0,0,0], "i8", ALLOC_NORMAL);
__str155=allocate([95,95,112,111,119,95,95,0], "i8", ALLOC_NORMAL);
__str154=allocate([112,111,119,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,42,42,32,98,46,0,0,0,0], "i8", ALLOC_NORMAL);
__str153=allocate([112,111,119,0], "i8", ALLOC_NORMAL);
__str152=allocate([95,95,100,101,108,105,116,101,109,95,95,0], "i8", ALLOC_NORMAL);
__str151=allocate([100,101,108,105,116,101,109,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,100,101,108,32,97,91,98,93,46,0,0], "i8", ALLOC_NORMAL);
__str150=allocate([100,101,108,105,116,101,109,0], "i8", ALLOC_NORMAL);
__str15=allocate([80,121,84,117,112,108,101,95,71,69,84,95,83,73,90,69,40,105,103,45,62,105,116,101,109,41,32,61,61,32,110,105,116,101,109,115,0,0,0,0], "i8", ALLOC_NORMAL);
__str149=allocate([95,95,115,101,116,105,116,101,109,95,95,0], "i8", ALLOC_NORMAL);
__str148=allocate([115,101,116,105,116,101,109,40,97,44,32,98,44,32,99,41,32,45,45,32,83,97,109,101,32,97,115,32,97,91,98,93,32,61,32,99,46,0,0,0], "i8", ALLOC_NORMAL);
__str147=allocate([115,101,116,105,116,101,109,0], "i8", ALLOC_NORMAL);
__str146=allocate([95,95,103,101,116,105,116,101,109,95,95,0], "i8", ALLOC_NORMAL);
__str145=allocate([103,101,116,105,116,101,109,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,91,98,93,46,0,0], "i8", ALLOC_NORMAL);
__str144=allocate([103,101,116,105,116,101,109,0], "i8", ALLOC_NORMAL);
__str143=allocate([95,95,105,114,101,112,101,97,116,95,95,0], "i8", ALLOC_NORMAL);
__str142=allocate([97,32,61,32,105,114,101,112,101,97,116,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,42,61,32,98,44,32,119,104,101,114,101,32,97,32,105,115,32,97,32,115,101,113,117,101,110,99,101,44,32,97,110,100,32,98,32,105,115,32,97,110,32,105,110,116,101,103,101,114,46,0,0,0,0], "i8", ALLOC_NORMAL);
__str141=allocate([105,114,101,112,101,97,116,0], "i8", ALLOC_NORMAL);
__str140=allocate([95,95,105,99,111,110,99,97,116,95,95,0], "i8", ALLOC_NORMAL);
__str14=allocate([80,121,84,117,112,108,101,95,67,104,101,99,107,40,105,103,45,62,105,116,101,109,41,0], "i8", ALLOC_NORMAL);
__str139=allocate([97,32,61,32,105,99,111,110,99,97,116,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,43,61,32,98,44,32,102,111,114,32,97,32,97,110,100,32,98,32,115,101,113,117,101,110,99,101,115,46,0], "i8", ALLOC_NORMAL);
__str138=allocate([105,99,111,110,99,97,116,0], "i8", ALLOC_NORMAL);
__str137=allocate([95,95,114,101,112,101,97,116,95,95,0,0], "i8", ALLOC_NORMAL);
__str136=allocate([114,101,112,101,97,116,40,97,44,32,98,41,32,45,45,32,82,101,116,117,114,110,32,97,32,42,32,98,44,32,119,104,101,114,101,32,97,32,105,115,32,97,32,115,101,113,117,101,110,99,101,44,32,97,110,100,32,98,32,105,115,32,97,110,32,105,110,116,101,103,101,114,46,0,0,0], "i8", ALLOC_NORMAL);
__str135=allocate([114,101,112,101,97,116,0,0], "i8", ALLOC_NORMAL);
__str134=allocate([95,95,99,111,110,99,97,116,95,95,0,0], "i8", ALLOC_NORMAL);
__str133=allocate([99,111,110,99,97,116,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,43,32,98,44,32,102,111,114,32,97,32,97,110,100,32,98,32,115,101,113,117,101,110,99,101,115,46,0,0,0], "i8", ALLOC_NORMAL);
__str132=allocate([99,111,110,99,97,116,0,0], "i8", ALLOC_NORMAL);
__str131=allocate([95,95,105,111,114,95,95,0], "i8", ALLOC_NORMAL);
__str130=allocate([97,32,61,32,105,111,114,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,124,61,32,98,46,0,0,0,0], "i8", ALLOC_NORMAL);
__str13=allocate([105,116,101,109,103,101,116,116,101,114,40,41,0,0,0,0], "i8", ALLOC_NORMAL);
__str129=allocate([105,111,114,0], "i8", ALLOC_NORMAL);
__str128=allocate([95,95,105,120,111,114,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str127=allocate([97,32,61,32,105,120,111,114,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,94,61,32,98,46,0,0,0], "i8", ALLOC_NORMAL);
__str126=allocate([105,120,111,114,0,0,0,0], "i8", ALLOC_NORMAL);
__str125=allocate([95,95,105,97,110,100,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str124=allocate([97,32,61,32,105,97,110,100,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,38,61,32,98,46,0,0,0], "i8", ALLOC_NORMAL);
__str123=allocate([105,97,110,100,0,0,0,0], "i8", ALLOC_NORMAL);
__str122=allocate([95,95,105,114,115,104,105,102,116,95,95,0], "i8", ALLOC_NORMAL);
__str121=allocate([97,32,61,32,105,114,115,104,105,102,116,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,62,62,61,32,98,46,0,0,0], "i8", ALLOC_NORMAL);
__str120=allocate([105,114,115,104,105,102,116,0], "i8", ALLOC_NORMAL);
__str12=allocate([111,112,101,114,97,116,111,114,46,105,116,101,109,103,101,116,116,101,114,0], "i8", ALLOC_NORMAL);
__str119=allocate([95,95,105,108,115,104,105,102,116,95,95,0], "i8", ALLOC_NORMAL);
__str118=allocate([97,32,61,32,105,108,115,104,105,102,116,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,60,60,61,32,98,46,0,0,0], "i8", ALLOC_NORMAL);
__str117=allocate([105,108,115,104,105,102,116,0], "i8", ALLOC_NORMAL);
__str116=allocate([95,95,105,109,111,100,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str115=allocate([97,32,61,32,105,109,111,100,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,37,61,32,98,46,0,0,0], "i8", ALLOC_NORMAL);
__str114=allocate([105,109,111,100,0,0,0,0], "i8", ALLOC_NORMAL);
__str113=allocate([95,95,105,116,114,117,101,100,105,118,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str112=allocate([97,32,61,32,105,116,114,117,101,100,105,118,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,47,61,32,98,32,119,104,101,110,32,95,95,102,117,116,117,114,101,95,95,46,100,105,118,105,115,105,111,110,32,105,115,32,105,110,32,101,102,102,101,99,116,46,0], "i8", ALLOC_NORMAL);
__str111=allocate([105,116,114,117,101,100,105,118,0,0,0,0], "i8", ALLOC_NORMAL);
__str110=allocate([95,95,105,102,108,111,111,114,100,105,118,95,95,0,0,0], "i8", ALLOC_NORMAL);
__str11=allocate([97,116,116,114,105,98,117,116,101,32,110,97,109,101,32,109,117,115,116,32,98,101,32,97,32,115,116,114,105,110,103,0], "i8", ALLOC_NORMAL);
__str109=allocate([97,32,61,32,105,102,108,111,111,114,100,105,118,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,47,47,61,32,98,46,0], "i8", ALLOC_NORMAL);
__str108=allocate([105,102,108,111,111,114,100,105,118,0,0,0], "i8", ALLOC_NORMAL);
__str107=allocate([95,95,105,100,105,118,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str106=allocate([97,32,61,32,105,100,105,118,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,47,61,32,98,32,119,104,101,110,32,95,95,102,117,116,117,114,101,95,95,46,100,105,118,105,115,105,111,110,32,105,115,32,110,111,116,32,105,110,32,101,102,102,101,99,116,46,0], "i8", ALLOC_NORMAL);
__str105=allocate([105,100,105,118,0,0,0,0], "i8", ALLOC_NORMAL);
__str104=allocate([95,95,105,109,117,108,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str103=allocate([97,32,61,32,105,109,117,108,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,42,61,32,98,46,0,0,0], "i8", ALLOC_NORMAL);
__str102=allocate([105,109,117,108,0,0,0,0], "i8", ALLOC_NORMAL);
__str101=allocate([95,95,105,115,117,98,95,95,0,0,0,0], "i8", ALLOC_NORMAL);
__str100=allocate([97,32,61,32,105,115,117,98,40,97,44,32,98,41,32,45,45,32,83,97,109,101,32,97,115,32,97,32,45,61,32,98,46,0,0,0], "i8", ALLOC_NORMAL);
__str10=allocate([80,121,84,117,112,108,101,95,71,69,84,95,83,73,90,69,40,97,103,45,62,97,116,116,114,41,32,61,61,32,110,97,116,116,114,115,0,0,0,0], "i8", ALLOC_NORMAL);
__str1=allocate([105,116,101,109,103,101,116,116,101,114,0,0], "i8", ALLOC_NORMAL);
__str=allocate([111,112,101,114,97,116,111,114,0,0,0,0], "i8", ALLOC_NORMAL);
___func___itemgetter_call=allocate([105,116,101,109,103,101,116,116,101,114,95,99,97,108,108,0], "i8", ALLOC_NORMAL);
___func___attrgetter_call=allocate([97,116,116,114,103,101,116,116,101,114,95,99,97,108,108,0], "i8", ALLOC_NORMAL);
/* no memory initializer */
function runPostSets() {
HEAP32[((_operator_methods)>>2)]=((__str16)|0);
HEAP32[(((_operator_methods)+(4))>>2)]=(FUNCTION_TABLE_OFFSET + 34);
HEAP32[(((_operator_methods)+(12))>>2)]=((__str17)|0);
HEAP32[(((_operator_methods)+(16))>>2)]=((__str18)|0);
HEAP32[(((_operator_methods)+(20))>>2)]=(FUNCTION_TABLE_OFFSET + 128);
HEAP32[(((_operator_methods)+(28))>>2)]=((__str19)|0);
HEAP32[(((_operator_methods)+(32))>>2)]=((__str20)|0);
HEAP32[(((_operator_methods)+(36))>>2)]=(FUNCTION_TABLE_OFFSET + 76);
HEAP32[(((_operator_methods)+(44))>>2)]=((__str21)|0);
HEAP32[(((_operator_methods)+(48))>>2)]=((__str22)|0);
HEAP32[(((_operator_methods)+(52))>>2)]=(FUNCTION_TABLE_OFFSET + 94);
HEAP32[(((_operator_methods)+(60))>>2)]=((__str23)|0);
HEAP32[(((_operator_methods)+(64))>>2)]=((__str24)|0);
HEAP32[(((_operator_methods)+(68))>>2)]=(FUNCTION_TABLE_OFFSET + 58);
HEAP32[(((_operator_methods)+(76))>>2)]=((__str25)|0);
HEAP32[(((_operator_methods)+(80))>>2)]=((__str26)|0);
HEAP32[(((_operator_methods)+(84))>>2)]=(FUNCTION_TABLE_OFFSET + 58);
HEAP32[(((_operator_methods)+(92))>>2)]=((__str25)|0);
HEAP32[(((_operator_methods)+(96))>>2)]=((__str27)|0);
HEAP32[(((_operator_methods)+(100))>>2)]=(FUNCTION_TABLE_OFFSET + 72);
HEAP32[(((_operator_methods)+(108))>>2)]=((__str28)|0);
HEAP32[(((_operator_methods)+(112))>>2)]=((__str29)|0);
HEAP32[(((_operator_methods)+(116))>>2)]=(FUNCTION_TABLE_OFFSET + 122);
HEAP32[(((_operator_methods)+(124))>>2)]=((__str30)|0);
HEAP32[(((_operator_methods)+(128))>>2)]=((__str31)|0);
HEAP32[(((_operator_methods)+(132))>>2)]=(FUNCTION_TABLE_OFFSET + 8);
HEAP32[(((_operator_methods)+(140))>>2)]=((__str32)|0);
HEAP32[(((_operator_methods)+(144))>>2)]=((__str33)|0);
HEAP32[(((_operator_methods)+(148))>>2)]=(FUNCTION_TABLE_OFFSET + 136);
HEAP32[(((_operator_methods)+(156))>>2)]=((__str34)|0);
HEAP32[(((_operator_methods)+(160))>>2)]=((__str35)|0);
HEAP32[(((_operator_methods)+(164))>>2)]=(FUNCTION_TABLE_OFFSET + 96);
HEAP32[(((_operator_methods)+(172))>>2)]=((__str36)|0);
HEAP32[(((_operator_methods)+(176))>>2)]=((__str37)|0);
HEAP32[(((_operator_methods)+(180))>>2)]=(FUNCTION_TABLE_OFFSET + 74);
HEAP32[(((_operator_methods)+(188))>>2)]=((__str38)|0);
HEAP32[(((_operator_methods)+(192))>>2)]=((__str39)|0);
HEAP32[(((_operator_methods)+(196))>>2)]=(FUNCTION_TABLE_OFFSET + 86);
HEAP32[(((_operator_methods)+(204))>>2)]=((__str40)|0);
HEAP32[(((_operator_methods)+(208))>>2)]=((__str41)|0);
HEAP32[(((_operator_methods)+(212))>>2)]=(FUNCTION_TABLE_OFFSET + 86);
HEAP32[(((_operator_methods)+(220))>>2)]=((__str40)|0);
HEAP32[(((_operator_methods)+(224))>>2)]=((__str42)|0);
HEAP32[(((_operator_methods)+(228))>>2)]=(FUNCTION_TABLE_OFFSET + 32);
HEAP32[(((_operator_methods)+(236))>>2)]=((__str43)|0);
HEAP32[(((_operator_methods)+(240))>>2)]=((__str44)|0);
HEAP32[(((_operator_methods)+(244))>>2)]=(FUNCTION_TABLE_OFFSET + 32);
HEAP32[(((_operator_methods)+(252))>>2)]=((__str43)|0);
HEAP32[(((_operator_methods)+(256))>>2)]=((__str45)|0);
HEAP32[(((_operator_methods)+(260))>>2)]=(FUNCTION_TABLE_OFFSET + 106);
HEAP32[(((_operator_methods)+(268))>>2)]=((__str46)|0);
HEAP32[(((_operator_methods)+(272))>>2)]=((__str47)|0);
HEAP32[(((_operator_methods)+(276))>>2)]=(FUNCTION_TABLE_OFFSET + 106);
HEAP32[(((_operator_methods)+(284))>>2)]=((__str46)|0);
HEAP32[(((_operator_methods)+(288))>>2)]=((__str48)|0);
HEAP32[(((_operator_methods)+(292))>>2)]=(FUNCTION_TABLE_OFFSET + 82);
HEAP32[(((_operator_methods)+(300))>>2)]=((__str49)|0);
HEAP32[(((_operator_methods)+(304))>>2)]=((__str50)|0);
HEAP32[(((_operator_methods)+(308))>>2)]=(FUNCTION_TABLE_OFFSET + 82);
HEAP32[(((_operator_methods)+(316))>>2)]=((__str49)|0);
HEAP32[(((_operator_methods)+(320))>>2)]=((__str51)|0);
HEAP32[(((_operator_methods)+(324))>>2)]=(FUNCTION_TABLE_OFFSET + 56);
HEAP32[(((_operator_methods)+(332))>>2)]=((__str52)|0);
HEAP32[(((_operator_methods)+(336))>>2)]=((__str53)|0);
HEAP32[(((_operator_methods)+(340))>>2)]=(FUNCTION_TABLE_OFFSET + 56);
HEAP32[(((_operator_methods)+(348))>>2)]=((__str52)|0);
HEAP32[(((_operator_methods)+(352))>>2)]=((__str54)|0);
HEAP32[(((_operator_methods)+(356))>>2)]=(FUNCTION_TABLE_OFFSET + 40);
HEAP32[(((_operator_methods)+(364))>>2)]=((__str55)|0);
HEAP32[(((_operator_methods)+(368))>>2)]=((__str56)|0);
HEAP32[(((_operator_methods)+(372))>>2)]=(FUNCTION_TABLE_OFFSET + 40);
HEAP32[(((_operator_methods)+(380))>>2)]=((__str55)|0);
HEAP32[(((_operator_methods)+(384))>>2)]=((__str57)|0);
HEAP32[(((_operator_methods)+(388))>>2)]=(FUNCTION_TABLE_OFFSET + 42);
HEAP32[(((_operator_methods)+(396))>>2)]=((__str58)|0);
HEAP32[(((_operator_methods)+(400))>>2)]=((__str59)|0);
HEAP32[(((_operator_methods)+(404))>>2)]=(FUNCTION_TABLE_OFFSET + 42);
HEAP32[(((_operator_methods)+(412))>>2)]=((__str58)|0);
HEAP32[(((_operator_methods)+(416))>>2)]=((__str60)|0);
HEAP32[(((_operator_methods)+(420))>>2)]=(FUNCTION_TABLE_OFFSET + 88);
HEAP32[(((_operator_methods)+(428))>>2)]=((__str61)|0);
HEAP32[(((_operator_methods)+(432))>>2)]=((__str62)|0);
HEAP32[(((_operator_methods)+(436))>>2)]=(FUNCTION_TABLE_OFFSET + 88);
HEAP32[(((_operator_methods)+(444))>>2)]=((__str61)|0);
HEAP32[(((_operator_methods)+(448))>>2)]=((__str63)|0);
HEAP32[(((_operator_methods)+(452))>>2)]=(FUNCTION_TABLE_OFFSET + 60);
HEAP32[(((_operator_methods)+(460))>>2)]=((__str64)|0);
HEAP32[(((_operator_methods)+(464))>>2)]=((__str65)|0);
HEAP32[(((_operator_methods)+(468))>>2)]=(FUNCTION_TABLE_OFFSET + 60);
HEAP32[(((_operator_methods)+(476))>>2)]=((__str64)|0);
HEAP32[(((_operator_methods)+(480))>>2)]=((__str66)|0);
HEAP32[(((_operator_methods)+(484))>>2)]=(FUNCTION_TABLE_OFFSET + 142);
HEAP32[(((_operator_methods)+(492))>>2)]=((__str67)|0);
HEAP32[(((_operator_methods)+(496))>>2)]=((__str68)|0);
HEAP32[(((_operator_methods)+(500))>>2)]=(FUNCTION_TABLE_OFFSET + 142);
HEAP32[(((_operator_methods)+(508))>>2)]=((__str67)|0);
HEAP32[(((_operator_methods)+(512))>>2)]=((__str69)|0);
HEAP32[(((_operator_methods)+(516))>>2)]=(FUNCTION_TABLE_OFFSET + 4);
HEAP32[(((_operator_methods)+(524))>>2)]=((__str70)|0);
HEAP32[(((_operator_methods)+(528))>>2)]=((__str71)|0);
HEAP32[(((_operator_methods)+(532))>>2)]=(FUNCTION_TABLE_OFFSET + 4);
HEAP32[(((_operator_methods)+(540))>>2)]=((__str70)|0);
HEAP32[(((_operator_methods)+(544))>>2)]=((__str72)|0);
HEAP32[(((_operator_methods)+(548))>>2)]=(FUNCTION_TABLE_OFFSET + 30);
HEAP32[(((_operator_methods)+(556))>>2)]=((__str73)|0);
HEAP32[(((_operator_methods)+(560))>>2)]=((__str74)|0);
HEAP32[(((_operator_methods)+(564))>>2)]=(FUNCTION_TABLE_OFFSET + 30);
HEAP32[(((_operator_methods)+(572))>>2)]=((__str73)|0);
HEAP32[(((_operator_methods)+(576))>>2)]=((__str75)|0);
HEAP32[(((_operator_methods)+(580))>>2)]=(FUNCTION_TABLE_OFFSET + 124);
HEAP32[(((_operator_methods)+(588))>>2)]=((__str76)|0);
HEAP32[(((_operator_methods)+(592))>>2)]=((__str77)|0);
HEAP32[(((_operator_methods)+(596))>>2)]=(FUNCTION_TABLE_OFFSET + 124);
HEAP32[(((_operator_methods)+(604))>>2)]=((__str76)|0);
HEAP32[(((_operator_methods)+(608))>>2)]=((__str78)|0);
HEAP32[(((_operator_methods)+(612))>>2)]=(FUNCTION_TABLE_OFFSET + 36);
HEAP32[(((_operator_methods)+(620))>>2)]=((__str79)|0);
HEAP32[(((_operator_methods)+(624))>>2)]=((__str80)|0);
HEAP32[(((_operator_methods)+(628))>>2)]=(FUNCTION_TABLE_OFFSET + 36);
HEAP32[(((_operator_methods)+(636))>>2)]=((__str79)|0);
HEAP32[(((_operator_methods)+(640))>>2)]=((__str81)|0);
HEAP32[(((_operator_methods)+(644))>>2)]=(FUNCTION_TABLE_OFFSET + 52);
HEAP32[(((_operator_methods)+(652))>>2)]=((__str82)|0);
HEAP32[(((_operator_methods)+(656))>>2)]=((__str83)|0);
HEAP32[(((_operator_methods)+(660))>>2)]=(FUNCTION_TABLE_OFFSET + 52);
HEAP32[(((_operator_methods)+(668))>>2)]=((__str82)|0);
HEAP32[(((_operator_methods)+(672))>>2)]=((__str84)|0);
HEAP32[(((_operator_methods)+(676))>>2)]=(FUNCTION_TABLE_OFFSET + 14);
HEAP32[(((_operator_methods)+(684))>>2)]=((__str85)|0);
HEAP32[(((_operator_methods)+(688))>>2)]=((__str86)|0);
HEAP32[(((_operator_methods)+(692))>>2)]=(FUNCTION_TABLE_OFFSET + 14);
HEAP32[(((_operator_methods)+(700))>>2)]=((__str85)|0);
HEAP32[(((_operator_methods)+(704))>>2)]=((__str87)|0);
HEAP32[(((_operator_methods)+(708))>>2)]=(FUNCTION_TABLE_OFFSET + 46);
HEAP32[(((_operator_methods)+(716))>>2)]=((__str88)|0);
HEAP32[(((_operator_methods)+(720))>>2)]=((__str89)|0);
HEAP32[(((_operator_methods)+(724))>>2)]=(FUNCTION_TABLE_OFFSET + 46);
HEAP32[(((_operator_methods)+(732))>>2)]=((__str88)|0);
HEAP32[(((_operator_methods)+(736))>>2)]=((__str90)|0);
HEAP32[(((_operator_methods)+(740))>>2)]=(FUNCTION_TABLE_OFFSET + 2);
HEAP32[(((_operator_methods)+(748))>>2)]=((__str91)|0);
HEAP32[(((_operator_methods)+(752))>>2)]=((__str92)|0);
HEAP32[(((_operator_methods)+(756))>>2)]=(FUNCTION_TABLE_OFFSET + 2);
HEAP32[(((_operator_methods)+(764))>>2)]=((__str91)|0);
HEAP32[(((_operator_methods)+(768))>>2)]=((__str93)|0);
HEAP32[(((_operator_methods)+(772))>>2)]=(FUNCTION_TABLE_OFFSET + 6);
HEAP32[(((_operator_methods)+(780))>>2)]=((__str94)|0);
HEAP32[(((_operator_methods)+(784))>>2)]=((__str95)|0);
HEAP32[(((_operator_methods)+(788))>>2)]=(FUNCTION_TABLE_OFFSET + 6);
HEAP32[(((_operator_methods)+(796))>>2)]=((__str94)|0);
HEAP32[(((_operator_methods)+(800))>>2)]=((__str96)|0);
HEAP32[(((_operator_methods)+(804))>>2)]=(FUNCTION_TABLE_OFFSET + 18);
HEAP32[(((_operator_methods)+(812))>>2)]=((__str97)|0);
HEAP32[(((_operator_methods)+(816))>>2)]=((__str98)|0);
HEAP32[(((_operator_methods)+(820))>>2)]=(FUNCTION_TABLE_OFFSET + 18);
HEAP32[(((_operator_methods)+(828))>>2)]=((__str97)|0);
HEAP32[(((_operator_methods)+(832))>>2)]=((__str99)|0);
HEAP32[(((_operator_methods)+(836))>>2)]=(FUNCTION_TABLE_OFFSET + 54);
HEAP32[(((_operator_methods)+(844))>>2)]=((__str100)|0);
HEAP32[(((_operator_methods)+(848))>>2)]=((__str101)|0);
HEAP32[(((_operator_methods)+(852))>>2)]=(FUNCTION_TABLE_OFFSET + 54);
HEAP32[(((_operator_methods)+(860))>>2)]=((__str100)|0);
HEAP32[(((_operator_methods)+(864))>>2)]=((__str102)|0);
HEAP32[(((_operator_methods)+(868))>>2)]=(FUNCTION_TABLE_OFFSET + 38);
HEAP32[(((_operator_methods)+(876))>>2)]=((__str103)|0);
HEAP32[(((_operator_methods)+(880))>>2)]=((__str104)|0);
HEAP32[(((_operator_methods)+(884))>>2)]=(FUNCTION_TABLE_OFFSET + 38);
HEAP32[(((_operator_methods)+(892))>>2)]=((__str103)|0);
HEAP32[(((_operator_methods)+(896))>>2)]=((__str105)|0);
HEAP32[(((_operator_methods)+(900))>>2)]=(FUNCTION_TABLE_OFFSET + 24);
HEAP32[(((_operator_methods)+(908))>>2)]=((__str106)|0);
HEAP32[(((_operator_methods)+(912))>>2)]=((__str107)|0);
HEAP32[(((_operator_methods)+(916))>>2)]=(FUNCTION_TABLE_OFFSET + 24);
HEAP32[(((_operator_methods)+(924))>>2)]=((__str106)|0);
HEAP32[(((_operator_methods)+(928))>>2)]=((__str108)|0);
HEAP32[(((_operator_methods)+(932))>>2)]=(FUNCTION_TABLE_OFFSET + 68);
HEAP32[(((_operator_methods)+(940))>>2)]=((__str109)|0);
HEAP32[(((_operator_methods)+(944))>>2)]=((__str110)|0);
HEAP32[(((_operator_methods)+(948))>>2)]=(FUNCTION_TABLE_OFFSET + 68);
HEAP32[(((_operator_methods)+(956))>>2)]=((__str109)|0);
HEAP32[(((_operator_methods)+(960))>>2)]=((__str111)|0);
HEAP32[(((_operator_methods)+(964))>>2)]=(FUNCTION_TABLE_OFFSET + 134);
HEAP32[(((_operator_methods)+(972))>>2)]=((__str112)|0);
HEAP32[(((_operator_methods)+(976))>>2)]=((__str113)|0);
HEAP32[(((_operator_methods)+(980))>>2)]=(FUNCTION_TABLE_OFFSET + 134);
HEAP32[(((_operator_methods)+(988))>>2)]=((__str112)|0);
HEAP32[(((_operator_methods)+(992))>>2)]=((__str114)|0);
HEAP32[(((_operator_methods)+(996))>>2)]=(FUNCTION_TABLE_OFFSET + 84);
HEAP32[(((_operator_methods)+(1004))>>2)]=((__str115)|0);
HEAP32[(((_operator_methods)+(1008))>>2)]=((__str116)|0);
HEAP32[(((_operator_methods)+(1012))>>2)]=(FUNCTION_TABLE_OFFSET + 84);
HEAP32[(((_operator_methods)+(1020))>>2)]=((__str115)|0);
HEAP32[(((_operator_methods)+(1024))>>2)]=((__str117)|0);
HEAP32[(((_operator_methods)+(1028))>>2)]=(FUNCTION_TABLE_OFFSET + 110);
HEAP32[(((_operator_methods)+(1036))>>2)]=((__str118)|0);
HEAP32[(((_operator_methods)+(1040))>>2)]=((__str119)|0);
HEAP32[(((_operator_methods)+(1044))>>2)]=(FUNCTION_TABLE_OFFSET + 110);
HEAP32[(((_operator_methods)+(1052))>>2)]=((__str118)|0);
HEAP32[(((_operator_methods)+(1056))>>2)]=((__str120)|0);
HEAP32[(((_operator_methods)+(1060))>>2)]=(FUNCTION_TABLE_OFFSET + 108);
HEAP32[(((_operator_methods)+(1068))>>2)]=((__str121)|0);
HEAP32[(((_operator_methods)+(1072))>>2)]=((__str122)|0);
HEAP32[(((_operator_methods)+(1076))>>2)]=(FUNCTION_TABLE_OFFSET + 108);
HEAP32[(((_operator_methods)+(1084))>>2)]=((__str121)|0);
HEAP32[(((_operator_methods)+(1088))>>2)]=((__str123)|0);
HEAP32[(((_operator_methods)+(1092))>>2)]=(FUNCTION_TABLE_OFFSET + 80);
HEAP32[(((_operator_methods)+(1100))>>2)]=((__str124)|0);
HEAP32[(((_operator_methods)+(1104))>>2)]=((__str125)|0);
HEAP32[(((_operator_methods)+(1108))>>2)]=(FUNCTION_TABLE_OFFSET + 80);
HEAP32[(((_operator_methods)+(1116))>>2)]=((__str124)|0);
HEAP32[(((_operator_methods)+(1120))>>2)]=((__str126)|0);
HEAP32[(((_operator_methods)+(1124))>>2)]=(FUNCTION_TABLE_OFFSET + 90);
HEAP32[(((_operator_methods)+(1132))>>2)]=((__str127)|0);
HEAP32[(((_operator_methods)+(1136))>>2)]=((__str128)|0);
HEAP32[(((_operator_methods)+(1140))>>2)]=(FUNCTION_TABLE_OFFSET + 90);
HEAP32[(((_operator_methods)+(1148))>>2)]=((__str127)|0);
HEAP32[(((_operator_methods)+(1152))>>2)]=((__str129)|0);
HEAP32[(((_operator_methods)+(1156))>>2)]=(FUNCTION_TABLE_OFFSET + 100);
HEAP32[(((_operator_methods)+(1164))>>2)]=((__str130)|0);
HEAP32[(((_operator_methods)+(1168))>>2)]=((__str131)|0);
HEAP32[(((_operator_methods)+(1172))>>2)]=(FUNCTION_TABLE_OFFSET + 100);
HEAP32[(((_operator_methods)+(1180))>>2)]=((__str130)|0);
HEAP32[(((_operator_methods)+(1184))>>2)]=((__str132)|0);
HEAP32[(((_operator_methods)+(1188))>>2)]=(FUNCTION_TABLE_OFFSET + 98);
HEAP32[(((_operator_methods)+(1196))>>2)]=((__str133)|0);
HEAP32[(((_operator_methods)+(1200))>>2)]=((__str134)|0);
HEAP32[(((_operator_methods)+(1204))>>2)]=(FUNCTION_TABLE_OFFSET + 98);
HEAP32[(((_operator_methods)+(1212))>>2)]=((__str133)|0);
HEAP32[(((_operator_methods)+(1216))>>2)]=((__str135)|0);
HEAP32[(((_operator_methods)+(1220))>>2)]=(FUNCTION_TABLE_OFFSET + 44);
HEAP32[(((_operator_methods)+(1228))>>2)]=((__str136)|0);
HEAP32[(((_operator_methods)+(1232))>>2)]=((__str137)|0);
HEAP32[(((_operator_methods)+(1236))>>2)]=(FUNCTION_TABLE_OFFSET + 44);
HEAP32[(((_operator_methods)+(1244))>>2)]=((__str136)|0);
HEAP32[(((_operator_methods)+(1248))>>2)]=((__str138)|0);
HEAP32[(((_operator_methods)+(1252))>>2)]=(FUNCTION_TABLE_OFFSET + 114);
HEAP32[(((_operator_methods)+(1260))>>2)]=((__str139)|0);
HEAP32[(((_operator_methods)+(1264))>>2)]=((__str140)|0);
HEAP32[(((_operator_methods)+(1268))>>2)]=(FUNCTION_TABLE_OFFSET + 114);
HEAP32[(((_operator_methods)+(1276))>>2)]=((__str139)|0);
HEAP32[(((_operator_methods)+(1280))>>2)]=((__str141)|0);
HEAP32[(((_operator_methods)+(1284))>>2)]=(FUNCTION_TABLE_OFFSET + 64);
HEAP32[(((_operator_methods)+(1292))>>2)]=((__str142)|0);
HEAP32[(((_operator_methods)+(1296))>>2)]=((__str143)|0);
HEAP32[(((_operator_methods)+(1300))>>2)]=(FUNCTION_TABLE_OFFSET + 64);
HEAP32[(((_operator_methods)+(1308))>>2)]=((__str142)|0);
HEAP32[(((_operator_methods)+(1312))>>2)]=((__str144)|0);
HEAP32[(((_operator_methods)+(1316))>>2)]=(FUNCTION_TABLE_OFFSET + 20);
HEAP32[(((_operator_methods)+(1324))>>2)]=((__str145)|0);
HEAP32[(((_operator_methods)+(1328))>>2)]=((__str146)|0);
HEAP32[(((_operator_methods)+(1332))>>2)]=(FUNCTION_TABLE_OFFSET + 20);
HEAP32[(((_operator_methods)+(1340))>>2)]=((__str145)|0);
HEAP32[(((_operator_methods)+(1344))>>2)]=((__str147)|0);
HEAP32[(((_operator_methods)+(1348))>>2)]=(FUNCTION_TABLE_OFFSET + 130);
HEAP32[(((_operator_methods)+(1356))>>2)]=((__str148)|0);
HEAP32[(((_operator_methods)+(1360))>>2)]=((__str149)|0);
HEAP32[(((_operator_methods)+(1364))>>2)]=(FUNCTION_TABLE_OFFSET + 130);
HEAP32[(((_operator_methods)+(1372))>>2)]=((__str148)|0);
HEAP32[(((_operator_methods)+(1376))>>2)]=((__str150)|0);
HEAP32[(((_operator_methods)+(1380))>>2)]=(FUNCTION_TABLE_OFFSET + 22);
HEAP32[(((_operator_methods)+(1388))>>2)]=((__str151)|0);
HEAP32[(((_operator_methods)+(1392))>>2)]=((__str152)|0);
HEAP32[(((_operator_methods)+(1396))>>2)]=(FUNCTION_TABLE_OFFSET + 22);
HEAP32[(((_operator_methods)+(1404))>>2)]=((__str151)|0);
HEAP32[(((_operator_methods)+(1408))>>2)]=((__str153)|0);
HEAP32[(((_operator_methods)+(1412))>>2)]=(FUNCTION_TABLE_OFFSET + 50);
HEAP32[(((_operator_methods)+(1420))>>2)]=((__str154)|0);
HEAP32[(((_operator_methods)+(1424))>>2)]=((__str155)|0);
HEAP32[(((_operator_methods)+(1428))>>2)]=(FUNCTION_TABLE_OFFSET + 50);
HEAP32[(((_operator_methods)+(1436))>>2)]=((__str154)|0);
HEAP32[(((_operator_methods)+(1440))>>2)]=((__str156)|0);
HEAP32[(((_operator_methods)+(1444))>>2)]=(FUNCTION_TABLE_OFFSET + 140);
HEAP32[(((_operator_methods)+(1452))>>2)]=((__str157)|0);
HEAP32[(((_operator_methods)+(1456))>>2)]=((__str158)|0);
HEAP32[(((_operator_methods)+(1460))>>2)]=(FUNCTION_TABLE_OFFSET + 140);
HEAP32[(((_operator_methods)+(1468))>>2)]=((__str157)|0);
HEAP32[(((_operator_methods)+(1472))>>2)]=((__str159)|0);
HEAP32[(((_operator_methods)+(1476))>>2)]=(FUNCTION_TABLE_OFFSET + 102);
HEAP32[(((_operator_methods)+(1484))>>2)]=((__str160)|0);
HEAP32[(((_operator_methods)+(1488))>>2)]=((__str161)|0);
HEAP32[(((_operator_methods)+(1492))>>2)]=(FUNCTION_TABLE_OFFSET + 102);
HEAP32[(((_operator_methods)+(1500))>>2)]=((__str160)|0);
HEAP32[(((_operator_methods)+(1504))>>2)]=((__str162)|0);
HEAP32[(((_operator_methods)+(1508))>>2)]=(FUNCTION_TABLE_OFFSET + 66);
HEAP32[(((_operator_methods)+(1516))>>2)]=((__str163)|0);
HEAP32[(((_operator_methods)+(1520))>>2)]=((__str164)|0);
HEAP32[(((_operator_methods)+(1524))>>2)]=(FUNCTION_TABLE_OFFSET + 66);
HEAP32[(((_operator_methods)+(1532))>>2)]=((__str163)|0);
HEAP32[(((_operator_methods)+(1536))>>2)]=((__str165)|0);
HEAP32[(((_operator_methods)+(1540))>>2)]=(FUNCTION_TABLE_OFFSET + 16);
HEAP32[(((_operator_methods)+(1548))>>2)]=((__str166)|0);
HEAP32[(((_operator_methods)+(1552))>>2)]=((__str167)|0);
HEAP32[(((_operator_methods)+(1556))>>2)]=(FUNCTION_TABLE_OFFSET + 16);
HEAP32[(((_operator_methods)+(1564))>>2)]=((__str166)|0);
HEAP32[(((_operator_methods)+(1568))>>2)]=((__str168)|0);
HEAP32[(((_operator_methods)+(1572))>>2)]=(FUNCTION_TABLE_OFFSET + 132);
HEAP32[(((_operator_methods)+(1580))>>2)]=((__str169)|0);
HEAP32[(((_operator_methods)+(1584))>>2)]=((__str170)|0);
HEAP32[(((_operator_methods)+(1588))>>2)]=(FUNCTION_TABLE_OFFSET + 132);
HEAP32[(((_operator_methods)+(1596))>>2)]=((__str169)|0);
HEAP32[(((_operator_methods)+(1600))>>2)]=((__str171)|0);
HEAP32[(((_operator_methods)+(1604))>>2)]=(FUNCTION_TABLE_OFFSET + 112);
HEAP32[(((_operator_methods)+(1612))>>2)]=((__str172)|0);
HEAP32[(((_operator_methods)+(1616))>>2)]=((__str173)|0);
HEAP32[(((_operator_methods)+(1620))>>2)]=(FUNCTION_TABLE_OFFSET + 112);
HEAP32[(((_operator_methods)+(1628))>>2)]=((__str172)|0);
HEAP32[(((_operator_methods)+(1632))>>2)]=((__str174)|0);
HEAP32[(((_operator_methods)+(1636))>>2)]=(FUNCTION_TABLE_OFFSET + 118);
HEAP32[(((_operator_methods)+(1644))>>2)]=((__str175)|0);
HEAP32[(((_operator_methods)+(1648))>>2)]=((__str176)|0);
HEAP32[(((_operator_methods)+(1652))>>2)]=(FUNCTION_TABLE_OFFSET + 118);
HEAP32[(((_operator_methods)+(1660))>>2)]=((__str175)|0);
HEAP32[(((_operator_methods)+(1664))>>2)]=((__str177)|0);
HEAP32[(((_operator_methods)+(1668))>>2)]=(FUNCTION_TABLE_OFFSET + 26);
HEAP32[(((_operator_methods)+(1676))>>2)]=((__str178)|0);
HEAP32[(((_operator_methods)+(1680))>>2)]=((__str179)|0);
HEAP32[(((_operator_methods)+(1684))>>2)]=(FUNCTION_TABLE_OFFSET + 26);
HEAP32[(((_operator_methods)+(1692))>>2)]=((__str178)|0);
HEAP32[(((_operator_methods)+(1696))>>2)]=((__str180)|0);
HEAP32[(((_operator_methods)+(1700))>>2)]=(FUNCTION_TABLE_OFFSET + 92);
HEAP32[(((_operator_methods)+(1708))>>2)]=((__str181)|0);
HEAP32[(((_operator_methods)+(1712))>>2)]=((__str182)|0);
HEAP32[(((_operator_methods)+(1716))>>2)]=(FUNCTION_TABLE_OFFSET + 92);
HEAP32[(((_operator_methods)+(1724))>>2)]=((__str181)|0);
HEAP32[(((_operator_methods)+(1728))>>2)]=((__str183)|0);
HEAP32[(((_operator_methods)+(1732))>>2)]=(FUNCTION_TABLE_OFFSET + 70);
HEAP32[(((_operator_methods)+(1740))>>2)]=((__str184)|0);
HEAP32[(((_operator_methods)+(1744))>>2)]=((__str185)|0);
HEAP32[(((_operator_methods)+(1748))>>2)]=(FUNCTION_TABLE_OFFSET + 70);
HEAP32[(((_operator_methods)+(1756))>>2)]=((__str184)|0);
HEAP32[(((_methodcaller_type)+(12))>>2)]=((__str4)|0);
HEAP32[(((_methodcaller_type)+(24))>>2)]=((FUNCTION_TABLE_OFFSET + 146));
HEAP32[(((_methodcaller_type)+(64))>>2)]=((FUNCTION_TABLE_OFFSET + 126));
HEAP32[(((_methodcaller_type)+(72))>>2)]=(FUNCTION_TABLE_OFFSET + 78);
HEAP32[(((_methodcaller_type)+(88))>>2)]=((_methodcaller_doc)|0);
HEAP32[(((_methodcaller_type)+(92))>>2)]=((FUNCTION_TABLE_OFFSET + 48));
HEAP32[(((_methodcaller_type)+(156))>>2)]=(FUNCTION_TABLE_OFFSET + 28);
HEAP32[(((_itemgetter_type)+(12))>>2)]=((__str12)|0);
HEAP32[(((_itemgetter_type)+(24))>>2)]=((FUNCTION_TABLE_OFFSET + 104));
HEAP32[(((_itemgetter_type)+(64))>>2)]=((FUNCTION_TABLE_OFFSET + 144));
HEAP32[(((_itemgetter_type)+(72))>>2)]=(FUNCTION_TABLE_OFFSET + 78);
HEAP32[(((_itemgetter_type)+(88))>>2)]=((_itemgetter_doc)|0);
HEAP32[(((_itemgetter_type)+(92))>>2)]=((FUNCTION_TABLE_OFFSET + 10));
HEAP32[(((_itemgetter_type)+(156))>>2)]=(FUNCTION_TABLE_OFFSET + 62);
HEAP32[(((_attrgetter_type)+(12))>>2)]=((__str6)|0);
HEAP32[(((_attrgetter_type)+(24))>>2)]=((FUNCTION_TABLE_OFFSET + 120));
HEAP32[(((_attrgetter_type)+(64))>>2)]=((FUNCTION_TABLE_OFFSET + 138));
HEAP32[(((_attrgetter_type)+(72))>>2)]=(FUNCTION_TABLE_OFFSET + 78);
HEAP32[(((_attrgetter_type)+(88))>>2)]=((_attrgetter_doc)|0);
HEAP32[(((_attrgetter_type)+(92))>>2)]=((FUNCTION_TABLE_OFFSET + 12));
HEAP32[(((_attrgetter_type)+(156))>>2)]=(FUNCTION_TABLE_OFFSET + 116);
}
if (!awaitingMemoryInitializer) runPostSets();
FUNCTION_TABLE.push.apply(FUNCTION_TABLE, [0,0,_op_xor,0,_op_abs,0,_op_or_,0,_countOf,0,_itemgetter_traverse
,0,_attrgetter_traverse,0,_op_not_,0,_op_delslice,0,_op_iadd,0,_op_getitem
,0,_op_delitem,0,_op_idiv,0,_op_ne,0,_methodcaller_new,0,_op_inv
,0,_op_add,0,_isCallable,0,_op_lshift,0,_op_imul,0,_op_floordiv
,0,_op_truediv,0,_op_repeat,0,_op_and_,0,_methodcaller_traverse,0,_op_pow
,0,_op_rshift,0,_op_isub,0,_op_div,0,_op_contains,0,_op_neg
,0,_itemgetter_new,0,_op_irepeat,0,_op_setslice,0,_op_ifloordiv,0,_op_ge
,0,_sequenceIncludes,0,_is_not,0,_isSequenceType,0,_PyObject_GenericGetAttr,0,_op_iand
,0,_op_mul,0,_op_imod,0,_op_index,0,_op_mod,0,_op_ixor
,0,_op_gt,0,_truth,0,_is_,0,_op_concat,0,_op_ior
,0,_op_getslice,0,_itemgetter_dealloc,0,_op_sub,0,_op_irshift,0,_op_ilshift
,0,_op_le,0,_op_iconcat,0,_attrgetter_new,0,_op_eq,0,_attrgetter_dealloc
,0,_indexOf,0,_op_invert,0,_methodcaller_call,0,_isNumberType,0,_op_setitem
,0,_op_lt,0,_op_itruediv,0,_isMappingType,0,_attrgetter_call,0,_op_ipow,0,_op_pos,0,_itemgetter_call,0,_methodcaller_dealloc,0]);
// EMSCRIPTEN_START_FUNCS
function _initoperator() {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $m;
      var $1=_Py_InitModule4(((__str)|0), ((_operator_methods)|0), ((_operator_doc)|0), 0, 1013);
      $m=$1;
      var $2=$m;
      var $3=(($2)|(0))==0;
      if ($3) { label = 2; break; } else { label = 3; break; }
    case 2: 
      label = 10; break;
    case 3: 
      var $6=_PyType_Ready(_itemgetter_type);
      var $7=(($6)|(0)) < 0;
      if ($7) { label = 4; break; } else { label = 5; break; }
    case 4: 
      label = 10; break;
    case 5: 
      var $10=HEAP32[((((_itemgetter_type)|0))>>2)];
      var $11=((($10)+(1))|0);
      HEAP32[((((_itemgetter_type)|0))>>2)]=$11;
      var $12=$m;
      var $13=_PyModule_AddObject($12, ((__str1)|0), _itemgetter_type);
      var $14=_PyType_Ready(_attrgetter_type);
      var $15=(($14)|(0)) < 0;
      if ($15) { label = 6; break; } else { label = 7; break; }
    case 6: 
      label = 10; break;
    case 7: 
      var $18=HEAP32[((((_attrgetter_type)|0))>>2)];
      var $19=((($18)+(1))|0);
      HEAP32[((((_attrgetter_type)|0))>>2)]=$19;
      var $20=$m;
      var $21=_PyModule_AddObject($20, ((__str2)|0), _attrgetter_type);
      var $22=_PyType_Ready(_methodcaller_type);
      var $23=(($22)|(0)) < 0;
      if ($23) { label = 8; break; } else { label = 9; break; }
    case 8: 
      label = 10; break;
    case 9: 
      var $26=HEAP32[((((_methodcaller_type)|0))>>2)];
      var $27=((($26)+(1))|0);
      HEAP32[((((_methodcaller_type)|0))>>2)]=$27;
      var $28=$m;
      var $29=_PyModule_AddObject($28, ((__str3)|0), _methodcaller_type);
      label = 10; break;
    case 10: 
      return;
    default: assert(0, "bad label: " + label);
  }
}
Module["_initoperator"] = _initoperator;
function _methodcaller_dealloc($mc) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      $1=$mc;
      var $2=$1;
      var $3=$2;
      _PyObject_GC_UnTrack($3);
      label = 2; break;
    case 2: 
      var $5=$1;
      var $6=(($5+8)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($7)|(0))==0;
      if ($8) { label = 3; break; } else { label = 4; break; }
    case 3: 
      label = 10; break;
    case 4: 
      label = 5; break;
    case 5: 
      var $12=$1;
      var $13=(($12+8)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=((($16)-(1))|0);
      HEAP32[(($15)>>2)]=$17;
      var $18=(($17)|(0))!=0;
      if ($18) { label = 6; break; } else { label = 7; break; }
    case 6: 
      label = 8; break;
    case 7: 
      var $21=$1;
      var $22=(($21+8)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=(($23+4)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25+24)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=$1;
      var $29=(($28+8)|0);
      var $30=HEAP32[(($29)>>2)];
      FUNCTION_TABLE[$27]($30);
      label = 8; break;
    case 8: 
      label = 9; break;
    case 9: 
      label = 10; break;
    case 10: 
      label = 11; break;
    case 11: 
      label = 12; break;
    case 12: 
      var $36=$1;
      var $37=(($36+12)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=(($38)|(0))==0;
      if ($39) { label = 13; break; } else { label = 14; break; }
    case 13: 
      label = 20; break;
    case 14: 
      label = 15; break;
    case 15: 
      var $43=$1;
      var $44=(($43+12)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=(($45)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=((($47)-(1))|0);
      HEAP32[(($46)>>2)]=$48;
      var $49=(($48)|(0))!=0;
      if ($49) { label = 16; break; } else { label = 17; break; }
    case 16: 
      label = 18; break;
    case 17: 
      var $52=$1;
      var $53=(($52+12)|0);
      var $54=HEAP32[(($53)>>2)];
      var $55=(($54+4)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=(($56+24)|0);
      var $58=HEAP32[(($57)>>2)];
      var $59=$1;
      var $60=(($59+12)|0);
      var $61=HEAP32[(($60)>>2)];
      FUNCTION_TABLE[$58]($61);
      label = 18; break;
    case 18: 
      label = 19; break;
    case 19: 
      label = 20; break;
    case 20: 
      label = 21; break;
    case 21: 
      label = 22; break;
    case 22: 
      var $67=$1;
      var $68=(($67+16)|0);
      var $69=HEAP32[(($68)>>2)];
      var $70=(($69)|(0))==0;
      if ($70) { label = 23; break; } else { label = 24; break; }
    case 23: 
      label = 30; break;
    case 24: 
      label = 25; break;
    case 25: 
      var $74=$1;
      var $75=(($74+16)|0);
      var $76=HEAP32[(($75)>>2)];
      var $77=(($76)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=((($78)-(1))|0);
      HEAP32[(($77)>>2)]=$79;
      var $80=(($79)|(0))!=0;
      if ($80) { label = 26; break; } else { label = 27; break; }
    case 26: 
      label = 28; break;
    case 27: 
      var $83=$1;
      var $84=(($83+16)|0);
      var $85=HEAP32[(($84)>>2)];
      var $86=(($85+4)|0);
      var $87=HEAP32[(($86)>>2)];
      var $88=(($87+24)|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=$1;
      var $91=(($90+16)|0);
      var $92=HEAP32[(($91)>>2)];
      FUNCTION_TABLE[$89]($92);
      label = 28; break;
    case 28: 
      label = 29; break;
    case 29: 
      label = 30; break;
    case 30: 
      label = 31; break;
    case 31: 
      var $97=$1;
      var $98=$97;
      _PyObject_GC_Del($98);
      return;
    default: assert(0, "bad label: " + label);
  }
}
function _methodcaller_call($mc, $args, $kw) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $method;
      var $obj=__stackBase__;
      var $result;
      $2=$mc;
      $3=$args;
      $4=$kw;
      var $5=$3;
      var $6=_PyArg_UnpackTuple($5, ((__str3)|0), 1, 1, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 4)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$obj,tempInt));
      var $7=(($6)|(0))!=0;
      if ($7) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 11; break;
    case 3: 
      var $10=HEAP32[(($obj)>>2)];
      var $11=$2;
      var $12=(($11+8)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=_PyObject_GetAttr($10, $13);
      $method=$14;
      var $15=$method;
      var $16=(($15)|(0))==0;
      if ($16) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $1=0;
      label = 11; break;
    case 5: 
      var $19=$method;
      var $20=$2;
      var $21=(($20+12)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=$2;
      var $24=(($23+16)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=_PyObject_Call($19, $22, $25);
      $result=$26;
      label = 6; break;
    case 6: 
      var $28=$method;
      var $29=(($28)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=((($30)-(1))|0);
      HEAP32[(($29)>>2)]=$31;
      var $32=(($31)|(0))!=0;
      if ($32) { label = 7; break; } else { label = 8; break; }
    case 7: 
      label = 9; break;
    case 8: 
      var $35=$method;
      var $36=(($35+4)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($37+24)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$method;
      FUNCTION_TABLE[$39]($40);
      label = 9; break;
    case 9: 
      label = 10; break;
    case 10: 
      var $43=$result;
      $1=$43;
      label = 11; break;
    case 11: 
      var $45=$1;
      STACKTOP = __stackBase__;
      return $45;
    default: assert(0, "bad label: " + label);
  }
}
function _methodcaller_traverse($mc, $visit, $arg) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $vret;
      var $vret1;
      $2=$mc;
      $3=$visit;
      $4=$arg;
      label = 2; break;
    case 2: 
      var $6=$2;
      var $7=(($6+12)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($8)|(0))!=0;
      if ($9) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $11=$3;
      var $12=$2;
      var $13=(($12+12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=$4;
      var $16=FUNCTION_TABLE[$11]($14, $15);
      $vret=$16;
      var $17=$vret;
      var $18=(($17)|(0))!=0;
      if ($18) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $20=$vret;
      $1=$20;
      label = 14; break;
    case 5: 
      label = 6; break;
    case 6: 
      label = 7; break;
    case 7: 
      label = 8; break;
    case 8: 
      var $25=$2;
      var $26=(($25+16)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=(($27)|(0))!=0;
      if ($28) { label = 9; break; } else { label = 12; break; }
    case 9: 
      var $30=$3;
      var $31=$2;
      var $32=(($31+16)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=$4;
      var $35=FUNCTION_TABLE[$30]($33, $34);
      $vret1=$35;
      var $36=$vret1;
      var $37=(($36)|(0))!=0;
      if ($37) { label = 10; break; } else { label = 11; break; }
    case 10: 
      var $39=$vret1;
      $1=$39;
      label = 14; break;
    case 11: 
      label = 12; break;
    case 12: 
      label = 13; break;
    case 13: 
      $1=0;
      label = 14; break;
    case 14: 
      var $44=$1;
      return $44;
    default: assert(0, "bad label: " + label);
  }
}
function _methodcaller_new($type, $args, $kwds) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $mc;
      var $name;
      var $newargs;
      $2=$type;
      $3=$args;
      $4=$kwds;
      var $5=$3;
      var $6=$5;
      var $7=(($6+8)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($8)|(0)) < 1;
      if ($9) { label = 2; break; } else { label = 3; break; }
    case 2: 
      var $11=HEAP32[((_PyExc_TypeError)>>2)];
      _PyErr_SetString($11, ((__str5)|0));
      $1=0;
      label = 18; break;
    case 3: 
      var $13=__PyObject_GC_New(_methodcaller_type);
      var $14=$13;
      $mc=$14;
      var $15=$mc;
      var $16=(($15)|(0))==0;
      if ($16) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $1=0;
      label = 18; break;
    case 5: 
      var $19=$3;
      var $20=$3;
      var $21=$20;
      var $22=(($21+8)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=_PyTuple_GetSlice($19, 1, $23);
      $newargs=$24;
      var $25=$newargs;
      var $26=(($25)|(0))==0;
      if ($26) { label = 6; break; } else { label = 12; break; }
    case 6: 
      label = 7; break;
    case 7: 
      var $29=$mc;
      var $30=$29;
      var $31=(($30)|0);
      var $32=HEAP32[(($31)>>2)];
      var $33=((($32)-(1))|0);
      HEAP32[(($31)>>2)]=$33;
      var $34=(($33)|(0))!=0;
      if ($34) { label = 8; break; } else { label = 9; break; }
    case 8: 
      label = 10; break;
    case 9: 
      var $37=$mc;
      var $38=$37;
      var $39=(($38+4)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=(($40+24)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$mc;
      var $44=$43;
      FUNCTION_TABLE[$42]($44);
      label = 10; break;
    case 10: 
      label = 11; break;
    case 11: 
      $1=0;
      label = 18; break;
    case 12: 
      var $48=$newargs;
      var $49=$mc;
      var $50=(($49+12)|0);
      HEAP32[(($50)>>2)]=$48;
      var $51=$3;
      var $52=$51;
      var $53=(($52+12)|0);
      var $54=(($53)|0);
      var $55=HEAP32[(($54)>>2)];
      $name=$55;
      var $56=$name;
      var $57=(($56)|0);
      var $58=HEAP32[(($57)>>2)];
      var $59=((($58)+(1))|0);
      HEAP32[(($57)>>2)]=$59;
      var $60=$name;
      var $61=$mc;
      var $62=(($61+8)|0);
      HEAP32[(($62)>>2)]=$60;
      label = 13; break;
    case 13: 
      var $64=$4;
      var $65=(($64)|(0))==0;
      if ($65) { label = 14; break; } else { label = 15; break; }
    case 14: 
      label = 16; break;
    case 15: 
      var $68=$4;
      var $69=(($68)|0);
      var $70=HEAP32[(($69)>>2)];
      var $71=((($70)+(1))|0);
      HEAP32[(($69)>>2)]=$71;
      label = 16; break;
    case 16: 
      label = 17; break;
    case 17: 
      var $74=$4;
      var $75=$mc;
      var $76=(($75+16)|0);
      HEAP32[(($76)>>2)]=$74;
      var $77=$mc;
      var $78=$77;
      _PyObject_GC_Track($78);
      var $79=$mc;
      var $80=$79;
      $1=$80;
      label = 18; break;
    case 18: 
      var $82=$1;
      return $82;
    default: assert(0, "bad label: " + label);
  }
}
function _attrgetter_dealloc($ag) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      $1=$ag;
      var $2=$1;
      var $3=$2;
      _PyObject_GC_UnTrack($3);
      label = 2; break;
    case 2: 
      var $5=$1;
      var $6=(($5+12)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($7)|(0))==0;
      if ($8) { label = 3; break; } else { label = 4; break; }
    case 3: 
      label = 10; break;
    case 4: 
      label = 5; break;
    case 5: 
      var $12=$1;
      var $13=(($12+12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=((($16)-(1))|0);
      HEAP32[(($15)>>2)]=$17;
      var $18=(($17)|(0))!=0;
      if ($18) { label = 6; break; } else { label = 7; break; }
    case 6: 
      label = 8; break;
    case 7: 
      var $21=$1;
      var $22=(($21+12)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=(($23+4)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25+24)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=$1;
      var $29=(($28+12)|0);
      var $30=HEAP32[(($29)>>2)];
      FUNCTION_TABLE[$27]($30);
      label = 8; break;
    case 8: 
      label = 9; break;
    case 9: 
      label = 10; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $35=$1;
      var $36=$35;
      _PyObject_GC_Del($36);
      return;
    default: assert(0, "bad label: " + label);
  }
}
function _attrgetter_traverse($ag, $visit, $arg) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $vret;
      $2=$ag;
      $3=$visit;
      $4=$arg;
      label = 2; break;
    case 2: 
      var $6=$2;
      var $7=(($6+12)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($8)|(0))!=0;
      if ($9) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $11=$3;
      var $12=$2;
      var $13=(($12+12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=$4;
      var $16=FUNCTION_TABLE[$11]($14, $15);
      $vret=$16;
      var $17=$vret;
      var $18=(($17)|(0))!=0;
      if ($18) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $20=$vret;
      $1=$20;
      label = 8; break;
    case 5: 
      label = 6; break;
    case 6: 
      label = 7; break;
    case 7: 
      $1=0;
      label = 8; break;
    case 8: 
      var $25=$1;
      return $25;
    default: assert(0, "bad label: " + label);
  }
}
function _attrgetter_new($type, $args, $kwds) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $ag;
      var $attr=__stackBase__;
      var $nattrs;
      $2=$type;
      $3=$args;
      $4=$kwds;
      var $5=$4;
      var $6=__PyArg_NoKeywords(((__str7)|0), $5);
      var $7=(($6)|(0))!=0;
      if ($7) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 11; break;
    case 3: 
      var $10=$3;
      var $11=$10;
      var $12=(($11+8)|0);
      var $13=HEAP32[(($12)>>2)];
      $nattrs=$13;
      var $14=$nattrs;
      var $15=(($14)|(0)) <= 1;
      if ($15) { label = 4; break; } else { label = 7; break; }
    case 4: 
      var $17=$3;
      var $18=_PyArg_UnpackTuple($17, ((__str2)|0), 1, 1, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 4)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$attr,tempInt));
      var $19=(($18)|(0))!=0;
      if ($19) { label = 6; break; } else { label = 5; break; }
    case 5: 
      $1=0;
      label = 11; break;
    case 6: 
      label = 8; break;
    case 7: 
      var $23=$3;
      HEAP32[(($attr)>>2)]=$23;
      label = 8; break;
    case 8: 
      var $25=__PyObject_GC_New(_attrgetter_type);
      var $26=$25;
      $ag=$26;
      var $27=$ag;
      var $28=(($27)|(0))==0;
      if ($28) { label = 9; break; } else { label = 10; break; }
    case 9: 
      $1=0;
      label = 11; break;
    case 10: 
      var $31=HEAP32[(($attr)>>2)];
      var $32=(($31)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=((($33)+(1))|0);
      HEAP32[(($32)>>2)]=$34;
      var $35=HEAP32[(($attr)>>2)];
      var $36=$ag;
      var $37=(($36+12)|0);
      HEAP32[(($37)>>2)]=$35;
      var $38=$nattrs;
      var $39=$ag;
      var $40=(($39+8)|0);
      HEAP32[(($40)>>2)]=$38;
      var $41=$ag;
      var $42=$41;
      _PyObject_GC_Track($42);
      var $43=$ag;
      var $44=$43;
      $1=$44;
      label = 11; break;
    case 11: 
      var $46=$1;
      STACKTOP = __stackBase__;
      return $46;
    default: assert(0, "bad label: " + label);
  }
}
function _attrgetter_call($ag, $args, $kw) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $obj=__stackBase__;
      var $result;
      var $i;
      var $nattrs;
      var $attr;
      var $val;
      $2=$ag;
      $3=$args;
      $4=$kw;
      var $5=$2;
      var $6=(($5+8)|0);
      var $7=HEAP32[(($6)>>2)];
      $nattrs=$7;
      var $8=$3;
      var $9=_PyArg_UnpackTuple($8, ((__str2)|0), 1, 1, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 4)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$obj,tempInt));
      var $10=(($9)|(0))!=0;
      if ($10) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 25; break;
    case 3: 
      var $13=$2;
      var $14=(($13+8)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15)|(0))==1;
      if ($16) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $18=HEAP32[(($obj)>>2)];
      var $19=$2;
      var $20=(($19+12)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=_dotted_getattr($18, $21);
      $1=$22;
      label = 25; break;
    case 5: 
      var $24=$2;
      var $25=(($24+12)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=(($26+4)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=(($28+84)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=$30 & 67108864;
      var $32=(($31)|(0))!=0;
      if ($32) { label = 6; break; } else { label = 7; break; }
    case 6: 
      label = 8; break;
    case 7: 
      ___assert_func(((__str8)|0), 571, ((___func___attrgetter_call)|0), ((__str9)|0));
      throw "Reached an unreachable!";
      label = 8; break;
    case 8: 
      var $37=$2;
      var $38=(($37+12)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=(($40+8)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$nattrs;
      var $44=(($42)|(0))==(($43)|(0));
      if ($44) { label = 9; break; } else { label = 10; break; }
    case 9: 
      label = 11; break;
    case 10: 
      ___assert_func(((__str8)|0), 572, ((___func___attrgetter_call)|0), ((__str10)|0));
      throw "Reached an unreachable!";
      label = 11; break;
    case 11: 
      var $49=$nattrs;
      var $50=_PyTuple_New($49);
      $result=$50;
      var $51=$result;
      var $52=(($51)|(0))==0;
      if ($52) { label = 12; break; } else { label = 13; break; }
    case 12: 
      $1=0;
      label = 25; break;
    case 13: 
      $i=0;
      label = 14; break;
    case 14: 
      var $56=$i;
      var $57=$nattrs;
      var $58=(($56)|(0)) < (($57)|(0));
      if ($58) { label = 15; break; } else { label = 24; break; }
    case 15: 
      var $60=$i;
      var $61=$2;
      var $62=(($61+12)|0);
      var $63=HEAP32[(($62)>>2)];
      var $64=$63;
      var $65=(($64+12)|0);
      var $66=(($65+($60<<2))|0);
      var $67=HEAP32[(($66)>>2)];
      $attr=$67;
      var $68=HEAP32[(($obj)>>2)];
      var $69=$attr;
      var $70=_dotted_getattr($68, $69);
      $val=$70;
      var $71=$val;
      var $72=(($71)|(0))==0;
      if ($72) { label = 16; break; } else { label = 22; break; }
    case 16: 
      label = 17; break;
    case 17: 
      var $75=$result;
      var $76=(($75)|0);
      var $77=HEAP32[(($76)>>2)];
      var $78=((($77)-(1))|0);
      HEAP32[(($76)>>2)]=$78;
      var $79=(($78)|(0))!=0;
      if ($79) { label = 18; break; } else { label = 19; break; }
    case 18: 
      label = 20; break;
    case 19: 
      var $82=$result;
      var $83=(($82+4)|0);
      var $84=HEAP32[(($83)>>2)];
      var $85=(($84+24)|0);
      var $86=HEAP32[(($85)>>2)];
      var $87=$result;
      FUNCTION_TABLE[$86]($87);
      label = 20; break;
    case 20: 
      label = 21; break;
    case 21: 
      $1=0;
      label = 25; break;
    case 22: 
      var $91=$val;
      var $92=$i;
      var $93=$result;
      var $94=$93;
      var $95=(($94+12)|0);
      var $96=(($95+($92<<2))|0);
      HEAP32[(($96)>>2)]=$91;
      label = 23; break;
    case 23: 
      var $98=$i;
      var $99=((($98)+(1))|0);
      $i=$99;
      label = 14; break;
    case 24: 
      var $101=$result;
      $1=$101;
      label = 25; break;
    case 25: 
      var $103=$1;
      STACKTOP = __stackBase__;
      return $103;
    default: assert(0, "bad label: " + label);
  }
}
function _dotted_getattr($obj, $attr) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $s;
      var $p;
      var $newobj;
      var $str;
      $2=$obj;
      $3=$attr;
      var $4=$3;
      var $5=(($4+4)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($6+84)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=$8 & 268435456;
      var $10=(($9)|(0))!=0;
      if ($10) { label = 2; break; } else { label = 5; break; }
    case 2: 
      var $12=$3;
      var $13=__PyUnicodeUCS2_AsDefaultEncodedString($12, 0);
      $3=$13;
      var $14=$3;
      var $15=(($14)|(0))==0;
      if ($15) { label = 3; break; } else { label = 4; break; }
    case 3: 
      $1=0;
      label = 34; break;
    case 4: 
      label = 5; break;
    case 5: 
      var $19=$3;
      var $20=(($19+4)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($21+84)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=$23 & 134217728;
      var $25=(($24)|(0))!=0;
      if ($25) { label = 7; break; } else { label = 6; break; }
    case 6: 
      var $27=HEAP32[((_PyExc_TypeError)>>2)];
      _PyErr_SetString($27, ((__str11)|0));
      $1=0;
      label = 34; break;
    case 7: 
      var $29=$3;
      var $30=$29;
      var $31=(($30+20)|0);
      var $32=(($31)|0);
      $s=$32;
      var $33=$2;
      var $34=(($33)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=((($35)+(1))|0);
      HEAP32[(($34)>>2)]=$36;
      label = 8; break;
    case 8: 
      var $38=$s;
      var $39=_strchr($38, 46);
      $p=$39;
      var $40=$p;
      var $41=(($40)|(0))!=0;
      if ($41) { label = 9; break; } else { label = 10; break; }
    case 9: 
      var $43=$s;
      var $44=$p;
      var $45=$s;
      var $46=$44;
      var $47=$45;
      var $48=((($46)-($47))|0);
      var $49=_PyString_FromStringAndSize($43, $48);
      var $54 = $49;label = 11; break;
    case 10: 
      var $51=$s;
      var $52=_PyString_FromString($51);
      var $54 = $52;label = 11; break;
    case 11: 
      var $54;
      $str=$54;
      var $55=$str;
      var $56=(($55)|(0))==0;
      if ($56) { label = 12; break; } else { label = 18; break; }
    case 12: 
      label = 13; break;
    case 13: 
      var $59=$2;
      var $60=(($59)|0);
      var $61=HEAP32[(($60)>>2)];
      var $62=((($61)-(1))|0);
      HEAP32[(($60)>>2)]=$62;
      var $63=(($62)|(0))!=0;
      if ($63) { label = 14; break; } else { label = 15; break; }
    case 14: 
      label = 16; break;
    case 15: 
      var $66=$2;
      var $67=(($66+4)|0);
      var $68=HEAP32[(($67)>>2)];
      var $69=(($68+24)|0);
      var $70=HEAP32[(($69)>>2)];
      var $71=$2;
      FUNCTION_TABLE[$70]($71);
      label = 16; break;
    case 16: 
      label = 17; break;
    case 17: 
      $1=0;
      label = 34; break;
    case 18: 
      var $75=$2;
      var $76=$str;
      var $77=_PyObject_GetAttr($75, $76);
      $newobj=$77;
      label = 19; break;
    case 19: 
      var $79=$str;
      var $80=(($79)|0);
      var $81=HEAP32[(($80)>>2)];
      var $82=((($81)-(1))|0);
      HEAP32[(($80)>>2)]=$82;
      var $83=(($82)|(0))!=0;
      if ($83) { label = 20; break; } else { label = 21; break; }
    case 20: 
      label = 22; break;
    case 21: 
      var $86=$str;
      var $87=(($86+4)|0);
      var $88=HEAP32[(($87)>>2)];
      var $89=(($88+24)|0);
      var $90=HEAP32[(($89)>>2)];
      var $91=$str;
      FUNCTION_TABLE[$90]($91);
      label = 22; break;
    case 22: 
      label = 23; break;
    case 23: 
      label = 24; break;
    case 24: 
      var $95=$2;
      var $96=(($95)|0);
      var $97=HEAP32[(($96)>>2)];
      var $98=((($97)-(1))|0);
      HEAP32[(($96)>>2)]=$98;
      var $99=(($98)|(0))!=0;
      if ($99) { label = 25; break; } else { label = 26; break; }
    case 25: 
      label = 27; break;
    case 26: 
      var $102=$2;
      var $103=(($102+4)|0);
      var $104=HEAP32[(($103)>>2)];
      var $105=(($104+24)|0);
      var $106=HEAP32[(($105)>>2)];
      var $107=$2;
      FUNCTION_TABLE[$106]($107);
      label = 27; break;
    case 27: 
      label = 28; break;
    case 28: 
      var $110=$newobj;
      var $111=(($110)|(0))==0;
      if ($111) { label = 29; break; } else { label = 30; break; }
    case 29: 
      $1=0;
      label = 34; break;
    case 30: 
      var $114=$newobj;
      $2=$114;
      var $115=$p;
      var $116=(($115)|(0))==0;
      if ($116) { label = 31; break; } else { label = 32; break; }
    case 31: 
      label = 33; break;
    case 32: 
      var $119=$p;
      var $120=(($119+1)|0);
      $s=$120;
      label = 8; break;
    case 33: 
      var $122=$2;
      $1=$122;
      label = 34; break;
    case 34: 
      var $124=$1;
      return $124;
    default: assert(0, "bad label: " + label);
  }
}
function _itemgetter_dealloc($ig) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      $1=$ig;
      var $2=$1;
      var $3=$2;
      _PyObject_GC_UnTrack($3);
      label = 2; break;
    case 2: 
      var $5=$1;
      var $6=(($5+12)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($7)|(0))==0;
      if ($8) { label = 3; break; } else { label = 4; break; }
    case 3: 
      label = 10; break;
    case 4: 
      label = 5; break;
    case 5: 
      var $12=$1;
      var $13=(($12+12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=((($16)-(1))|0);
      HEAP32[(($15)>>2)]=$17;
      var $18=(($17)|(0))!=0;
      if ($18) { label = 6; break; } else { label = 7; break; }
    case 6: 
      label = 8; break;
    case 7: 
      var $21=$1;
      var $22=(($21+12)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=(($23+4)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25+24)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=$1;
      var $29=(($28+12)|0);
      var $30=HEAP32[(($29)>>2)];
      FUNCTION_TABLE[$27]($30);
      label = 8; break;
    case 8: 
      label = 9; break;
    case 9: 
      label = 10; break;
    case 10: 
      label = 11; break;
    case 11: 
      var $35=$1;
      var $36=$35;
      _PyObject_GC_Del($36);
      return;
    default: assert(0, "bad label: " + label);
  }
}
function _itemgetter_traverse($ig, $visit, $arg) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $vret;
      $2=$ig;
      $3=$visit;
      $4=$arg;
      label = 2; break;
    case 2: 
      var $6=$2;
      var $7=(($6+12)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($8)|(0))!=0;
      if ($9) { label = 3; break; } else { label = 6; break; }
    case 3: 
      var $11=$3;
      var $12=$2;
      var $13=(($12+12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=$4;
      var $16=FUNCTION_TABLE[$11]($14, $15);
      $vret=$16;
      var $17=$vret;
      var $18=(($17)|(0))!=0;
      if ($18) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $20=$vret;
      $1=$20;
      label = 8; break;
    case 5: 
      label = 6; break;
    case 6: 
      label = 7; break;
    case 7: 
      $1=0;
      label = 8; break;
    case 8: 
      var $25=$1;
      return $25;
    default: assert(0, "bad label: " + label);
  }
}
function _itemgetter_new($type, $args, $kwds) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $ig;
      var $item=__stackBase__;
      var $nitems;
      $2=$type;
      $3=$args;
      $4=$kwds;
      var $5=$4;
      var $6=__PyArg_NoKeywords(((__str13)|0), $5);
      var $7=(($6)|(0))!=0;
      if ($7) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 11; break;
    case 3: 
      var $10=$3;
      var $11=$10;
      var $12=(($11+8)|0);
      var $13=HEAP32[(($12)>>2)];
      $nitems=$13;
      var $14=$nitems;
      var $15=(($14)|(0)) <= 1;
      if ($15) { label = 4; break; } else { label = 7; break; }
    case 4: 
      var $17=$3;
      var $18=_PyArg_UnpackTuple($17, ((__str1)|0), 1, 1, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 4)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$item,tempInt));
      var $19=(($18)|(0))!=0;
      if ($19) { label = 6; break; } else { label = 5; break; }
    case 5: 
      $1=0;
      label = 11; break;
    case 6: 
      label = 8; break;
    case 7: 
      var $23=$3;
      HEAP32[(($item)>>2)]=$23;
      label = 8; break;
    case 8: 
      var $25=__PyObject_GC_New(_itemgetter_type);
      var $26=$25;
      $ig=$26;
      var $27=$ig;
      var $28=(($27)|(0))==0;
      if ($28) { label = 9; break; } else { label = 10; break; }
    case 9: 
      $1=0;
      label = 11; break;
    case 10: 
      var $31=HEAP32[(($item)>>2)];
      var $32=(($31)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=((($33)+(1))|0);
      HEAP32[(($32)>>2)]=$34;
      var $35=HEAP32[(($item)>>2)];
      var $36=$ig;
      var $37=(($36+12)|0);
      HEAP32[(($37)>>2)]=$35;
      var $38=$nitems;
      var $39=$ig;
      var $40=(($39+8)|0);
      HEAP32[(($40)>>2)]=$38;
      var $41=$ig;
      var $42=$41;
      _PyObject_GC_Track($42);
      var $43=$ig;
      var $44=$43;
      $1=$44;
      label = 11; break;
    case 11: 
      var $46=$1;
      STACKTOP = __stackBase__;
      return $46;
    default: assert(0, "bad label: " + label);
  }
}
function _isCallable($s, $a1) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $r;
      $2=$s;
      $3=$a1;
      var $4=$3;
      var $5=_op_isCallable($4);
      $r=$5;
      var $6=-1==(($5)|(0));
      if ($6) { label = 2; break; } else { label = 3; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=$r;
      var $10=_PyBool_FromLong($9);
      $1=$10;
      label = 4; break;
    case 4: 
      var $12=$1;
      return $12;
    default: assert(0, "bad label: " + label);
  }
}
function _isNumberType($s, $a1) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $r;
      $2=$s;
      $3=$a1;
      var $4=$3;
      var $5=_PyNumber_Check($4);
      $r=$5;
      var $6=-1==(($5)|(0));
      if ($6) { label = 2; break; } else { label = 3; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=$r;
      var $10=_PyBool_FromLong($9);
      $1=$10;
      label = 4; break;
    case 4: 
      var $12=$1;
      return $12;
    default: assert(0, "bad label: " + label);
  }
}
function _isSequenceType($s, $a1) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $r;
      $2=$s;
      $3=$a1;
      var $4=$3;
      var $5=_PySequence_Check($4);
      $r=$5;
      var $6=-1==(($5)|(0));
      if ($6) { label = 2; break; } else { label = 3; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=$r;
      var $10=_PyBool_FromLong($9);
      $1=$10;
      label = 4; break;
    case 4: 
      var $12=$1;
      return $12;
    default: assert(0, "bad label: " + label);
  }
}
function _truth($s, $a1) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $r;
      $2=$s;
      $3=$a1;
      var $4=$3;
      var $5=_PyObject_IsTrue($4);
      $r=$5;
      var $6=-1==(($5)|(0));
      if ($6) { label = 2; break; } else { label = 3; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=$r;
      var $10=_PyBool_FromLong($9);
      $1=$10;
      label = 4; break;
    case 4: 
      var $12=$1;
      return $12;
    default: assert(0, "bad label: " + label);
  }
}
function _op_contains($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      var $r;
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str227)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 6; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PySequence_Contains($9, $10);
      $r=$11;
      var $12=-1==(($11)|(0));
      if ($12) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $1=0;
      label = 6; break;
    case 5: 
      var $15=$r;
      var $16=_PyBool_FromLong($15);
      $1=$16;
      label = 6; break;
    case 6: 
      var $18=$1;
      STACKTOP = __stackBase__;
      return $18;
    default: assert(0, "bad label: " + label);
  }
}
function _sequenceIncludes($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      var $r;
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str27)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 6; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_op_sequenceIncludes($9, $10);
      $r=$11;
      var $12=-1==(($11)|(0));
      if ($12) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $1=0;
      label = 6; break;
    case 5: 
      var $15=$r;
      var $16=_PyBool_FromLong($15);
      $1=$16;
      label = 6; break;
    case 6: 
      var $18=$1;
      STACKTOP = __stackBase__;
      return $18;
    default: assert(0, "bad label: " + label);
  }
}
function _indexOf($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      var $r;
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str29)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 6; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PySequence_Index($9, $10);
      $r=$11;
      var $12=-1==(($11)|(0));
      if ($12) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $1=0;
      label = 6; break;
    case 5: 
      var $15=$r;
      var $16=_PyInt_FromSsize_t($15);
      $1=$16;
      label = 6; break;
    case 6: 
      var $18=$1;
      STACKTOP = __stackBase__;
      return $18;
    default: assert(0, "bad label: " + label);
  }
}
function _countOf($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      var $r;
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str31)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 6; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PySequence_Count($9, $10);
      $r=$11;
      var $12=-1==(($11)|(0));
      if ($12) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $1=0;
      label = 6; break;
    case 5: 
      var $15=$r;
      var $16=_PyInt_FromSsize_t($15);
      $1=$16;
      label = 6; break;
    case 6: 
      var $18=$1;
      STACKTOP = __stackBase__;
      return $18;
    default: assert(0, "bad label: " + label);
  }
}
function _isMappingType($s, $a1) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $r;
      $2=$s;
      $3=$a1;
      var $4=$3;
      var $5=_PyMapping_Check($4);
      $r=$5;
      var $6=-1==(($5)|(0));
      if ($6) { label = 2; break; } else { label = 3; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=$r;
      var $10=_PyBool_FromLong($9);
      $1=$10;
      label = 4; break;
    case 4: 
      var $12=$1;
      return $12;
    default: assert(0, "bad label: " + label);
  }
}
function _is_($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      var $result;
      $1=$s;
      $2=$a;
      $result=0;
      var $3=$2;
      var $4=_PyArg_UnpackTuple($3, ((__str35)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $5=(($4)|(0))!=0;
      if ($5) { label = 2; break; } else { label = 3; break; }
    case 2: 
      var $7=HEAP32[(($a1)>>2)];
      var $8=HEAP32[(($a2)>>2)];
      var $9=(($7)|(0))==(($8)|(0));
      var $10=$9 ? __Py_TrueStruct : __Py_ZeroStruct;
      $result=$10;
      var $11=$result;
      var $12=(($11)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=((($13)+(1))|0);
      HEAP32[(($12)>>2)]=$14;
      label = 3; break;
    case 3: 
      var $16=$result;
      STACKTOP = __stackBase__;
      return $16;
    default: assert(0, "bad label: " + label);
  }
}
function _is_not($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      var $result;
      $1=$s;
      $2=$a;
      $result=0;
      var $3=$2;
      var $4=_PyArg_UnpackTuple($3, ((__str37)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $5=(($4)|(0))!=0;
      if ($5) { label = 2; break; } else { label = 3; break; }
    case 2: 
      var $7=HEAP32[(($a1)>>2)];
      var $8=HEAP32[(($a2)>>2)];
      var $9=(($7)|(0))!=(($8)|(0));
      var $10=$9 ? __Py_TrueStruct : __Py_ZeroStruct;
      $result=$10;
      var $11=$result;
      var $12=(($11)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=((($13)+(1))|0);
      HEAP32[(($12)>>2)]=$14;
      label = 3; break;
    case 3: 
      var $16=$result;
      STACKTOP = __stackBase__;
      return $16;
    default: assert(0, "bad label: " + label);
  }
}
function _op_index($s, $a) {
  var label = 0;
  var $1;
  var $2;
  $1=$s;
  $2=$a;
  var $3=$2;
  var $4=_PyNumber_Index($3);
  return $4;
}
function _op_add($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str225)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_Add($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _itemgetter_call($ig, $args, $kw) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 4)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $obj=__stackBase__;
      var $result;
      var $i;
      var $nitems;
      var $item;
      var $val;
      $2=$ig;
      $3=$args;
      $4=$kw;
      var $5=$2;
      var $6=(($5+8)|0);
      var $7=HEAP32[(($6)>>2)];
      $nitems=$7;
      var $8=$3;
      var $9=_PyArg_UnpackTuple($8, ((__str1)|0), 1, 1, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 4)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$obj,tempInt));
      var $10=(($9)|(0))!=0;
      if ($10) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 25; break;
    case 3: 
      var $13=$nitems;
      var $14=(($13)|(0))==1;
      if ($14) { label = 4; break; } else { label = 5; break; }
    case 4: 
      var $16=HEAP32[(($obj)>>2)];
      var $17=$2;
      var $18=(($17+12)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=_PyObject_GetItem($16, $19);
      $1=$20;
      label = 25; break;
    case 5: 
      var $22=$2;
      var $23=(($22+12)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24+4)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=(($26+84)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=$28 & 67108864;
      var $30=(($29)|(0))!=0;
      if ($30) { label = 6; break; } else { label = 7; break; }
    case 6: 
      label = 8; break;
    case 7: 
      ___assert_func(((__str8)|0), 391, ((___func___itemgetter_call)|0), ((__str14)|0));
      throw "Reached an unreachable!";
      label = 8; break;
    case 8: 
      var $35=$2;
      var $36=(($35+12)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=$37;
      var $39=(($38+8)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=$nitems;
      var $42=(($40)|(0))==(($41)|(0));
      if ($42) { label = 9; break; } else { label = 10; break; }
    case 9: 
      label = 11; break;
    case 10: 
      ___assert_func(((__str8)|0), 392, ((___func___itemgetter_call)|0), ((__str15)|0));
      throw "Reached an unreachable!";
      label = 11; break;
    case 11: 
      var $47=$nitems;
      var $48=_PyTuple_New($47);
      $result=$48;
      var $49=$result;
      var $50=(($49)|(0))==0;
      if ($50) { label = 12; break; } else { label = 13; break; }
    case 12: 
      $1=0;
      label = 25; break;
    case 13: 
      $i=0;
      label = 14; break;
    case 14: 
      var $54=$i;
      var $55=$nitems;
      var $56=(($54)|(0)) < (($55)|(0));
      if ($56) { label = 15; break; } else { label = 24; break; }
    case 15: 
      var $58=$i;
      var $59=$2;
      var $60=(($59+12)|0);
      var $61=HEAP32[(($60)>>2)];
      var $62=$61;
      var $63=(($62+12)|0);
      var $64=(($63+($58<<2))|0);
      var $65=HEAP32[(($64)>>2)];
      $item=$65;
      var $66=HEAP32[(($obj)>>2)];
      var $67=$item;
      var $68=_PyObject_GetItem($66, $67);
      $val=$68;
      var $69=$val;
      var $70=(($69)|(0))==0;
      if ($70) { label = 16; break; } else { label = 22; break; }
    case 16: 
      label = 17; break;
    case 17: 
      var $73=$result;
      var $74=(($73)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=((($75)-(1))|0);
      HEAP32[(($74)>>2)]=$76;
      var $77=(($76)|(0))!=0;
      if ($77) { label = 18; break; } else { label = 19; break; }
    case 18: 
      label = 20; break;
    case 19: 
      var $80=$result;
      var $81=(($80+4)|0);
      var $82=HEAP32[(($81)>>2)];
      var $83=(($82+24)|0);
      var $84=HEAP32[(($83)>>2)];
      var $85=$result;
      FUNCTION_TABLE[$84]($85);
      label = 20; break;
    case 20: 
      label = 21; break;
    case 21: 
      $1=0;
      label = 25; break;
    case 22: 
      var $89=$val;
      var $90=$i;
      var $91=$result;
      var $92=$91;
      var $93=(($92+12)|0);
      var $94=(($93+($90<<2))|0);
      HEAP32[(($94)>>2)]=$89;
      label = 23; break;
    case 23: 
      var $96=$i;
      var $97=((($96)+(1))|0);
      $i=$97;
      label = 14; break;
    case 24: 
      var $99=$result;
      $1=$99;
      label = 25; break;
    case 25: 
      var $101=$1;
      STACKTOP = __stackBase__;
      return $101;
    default: assert(0, "bad label: " + label);
  }
}
function _op_sub($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str224)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_Subtract($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_mul($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str223)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_Multiply($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_div($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str222)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_Divide($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_floordiv($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str221)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_FloorDivide($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_truediv($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str220)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_TrueDivide($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_mod($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str219)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_Remainder($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_neg($s, $a1) {
  var label = 0;
  var $1;
  var $2;
  $1=$s;
  $2=$a1;
  var $3=$2;
  var $4=_PyNumber_Negative($3);
  return $4;
}
function _op_pos($s, $a1) {
  var label = 0;
  var $1;
  var $2;
  $1=$s;
  $2=$a1;
  var $3=$2;
  var $4=_PyNumber_Positive($3);
  return $4;
}
function _op_abs($s, $a1) {
  var label = 0;
  var $1;
  var $2;
  $1=$s;
  $2=$a1;
  var $3=$2;
  var $4=_PyNumber_Absolute($3);
  return $4;
}
function _op_inv($s, $a1) {
  var label = 0;
  var $1;
  var $2;
  $1=$s;
  $2=$a1;
  var $3=$2;
  var $4=_PyNumber_Invert($3);
  return $4;
}
function _op_invert($s, $a1) {
  var label = 0;
  var $1;
  var $2;
  $1=$s;
  $2=$a1;
  var $3=$2;
  var $4=_PyNumber_Invert($3);
  return $4;
}
function _op_lshift($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str218)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_Lshift($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_rshift($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str217)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_Rshift($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_not_($s, $a1) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $r;
      $2=$s;
      $3=$a1;
      var $4=$3;
      var $5=_PyObject_Not($4);
      $r=$5;
      var $6=-1==(($5)|(0));
      if ($6) { label = 2; break; } else { label = 3; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=$r;
      var $10=_PyBool_FromLong($9);
      $1=$10;
      label = 4; break;
    case 4: 
      var $12=$1;
      return $12;
    default: assert(0, "bad label: " + label);
  }
}
function _op_and_($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str216)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_And($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_xor($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str215)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_Xor($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_or_($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str214)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_Or($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_iadd($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str213)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_InPlaceAdd($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_isub($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str212)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_InPlaceSubtract($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_imul($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str211)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_InPlaceMultiply($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_idiv($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str210)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_InPlaceDivide($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_ifloordiv($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str209)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_InPlaceFloorDivide($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_itruediv($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str208)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_InPlaceTrueDivide($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_imod($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str207)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_InPlaceRemainder($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_ilshift($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str206)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_InPlaceLshift($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_irshift($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str205)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_InPlaceRshift($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_iand($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str204)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_InPlaceAnd($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_ixor($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str203)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_InPlaceXor($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_ior($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str202)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyNumber_InPlaceOr($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_concat($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str201)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PySequence_Concat($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_repeat($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_ParseTuple($4, ((__str200)|0), (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PySequence_Repeat($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_iconcat($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str199)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PySequence_InPlaceConcat($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_irepeat($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_ParseTuple($4, ((__str198)|0), (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PySequence_InPlaceRepeat($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_getitem($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str197)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyObject_GetItem($9, $10);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_setitem($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      var $a3=(__stackBase__)+(8);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str196)|0), 3, 3, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 12)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,HEAP32[(((tempInt)+(8))>>2)]=$a3,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 6; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=HEAP32[(($a3)>>2)];
      var $12=_PyObject_SetItem($9, $10, $11);
      var $13=-1==(($12)|(0));
      if ($13) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $1=0;
      label = 6; break;
    case 5: 
      var $16=HEAP32[((((__Py_NoneStruct)|0))>>2)];
      var $17=((($16)+(1))|0);
      HEAP32[((((__Py_NoneStruct)|0))>>2)]=$17;
      $1=__Py_NoneStruct;
      label = 6; break;
    case 6: 
      var $19=$1;
      STACKTOP = __stackBase__;
      return $19;
    default: assert(0, "bad label: " + label);
  }
}
function _op_delitem($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str195)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 6; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyObject_DelItem($9, $10);
      var $12=-1==(($11)|(0));
      if ($12) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $1=0;
      label = 6; break;
    case 5: 
      var $15=HEAP32[((((__Py_NoneStruct)|0))>>2)];
      var $16=((($15)+(1))|0);
      HEAP32[((((__Py_NoneStruct)|0))>>2)]=$16;
      $1=__Py_NoneStruct;
      label = 6; break;
    case 6: 
      var $18=$1;
      STACKTOP = __stackBase__;
      return $18;
    default: assert(0, "bad label: " + label);
  }
}
function _op_pow($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str153)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 2; break; } else { label = 3; break; }
    case 2: 
      var $8=HEAP32[(($a1)>>2)];
      var $9=HEAP32[(($a2)>>2)];
      var $10=_PyNumber_Power($8, $9, __Py_NoneStruct);
      $1=$10;
      label = 4; break;
    case 3: 
      $1=0;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_ipow($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str156)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 2; break; } else { label = 3; break; }
    case 2: 
      var $8=HEAP32[(($a1)>>2)];
      var $9=HEAP32[(($a2)>>2)];
      var $10=_PyNumber_InPlacePower($8, $9, __Py_NoneStruct);
      $1=$10;
      label = 4; break;
    case 3: 
      $1=0;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_getslice($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      var $a3=(__stackBase__)+(8);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_ParseTuple($4, ((__str194)|0), (tempInt=STACKTOP,STACKTOP = (STACKTOP + 12)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,HEAP32[(((tempInt)+(8))>>2)]=$a3,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=HEAP32[(($a3)>>2)];
      var $12=_PySequence_GetSlice($9, $10, $11);
      $1=$12;
      label = 4; break;
    case 4: 
      var $14=$1;
      STACKTOP = __stackBase__;
      return $14;
    default: assert(0, "bad label: " + label);
  }
}
function _op_setslice($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 16)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a4=(__stackBase__)+(4);
      var $a2=(__stackBase__)+(8);
      var $a3=(__stackBase__)+(12);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_ParseTuple($4, ((__str193)|0), (tempInt=STACKTOP,STACKTOP = (STACKTOP + 16)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,HEAP32[(((tempInt)+(8))>>2)]=$a3,HEAP32[(((tempInt)+(12))>>2)]=$a4,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 6; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=HEAP32[(($a3)>>2)];
      var $12=HEAP32[(($a4)>>2)];
      var $13=_PySequence_SetSlice($9, $10, $11, $12);
      var $14=-1==(($13)|(0));
      if ($14) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $1=0;
      label = 6; break;
    case 5: 
      var $17=HEAP32[((((__Py_NoneStruct)|0))>>2)];
      var $18=((($17)+(1))|0);
      HEAP32[((((__Py_NoneStruct)|0))>>2)]=$18;
      $1=__Py_NoneStruct;
      label = 6; break;
    case 6: 
      var $20=$1;
      STACKTOP = __stackBase__;
      return $20;
    default: assert(0, "bad label: " + label);
  }
}
function _op_delslice($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 12)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      var $a3=(__stackBase__)+(8);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_ParseTuple($4, ((__str192)|0), (tempInt=STACKTOP,STACKTOP = (STACKTOP + 12)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,HEAP32[(((tempInt)+(8))>>2)]=$a3,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 6; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=HEAP32[(($a3)>>2)];
      var $12=_PySequence_DelSlice($9, $10, $11);
      var $13=-1==(($12)|(0));
      if ($13) { label = 4; break; } else { label = 5; break; }
    case 4: 
      $1=0;
      label = 6; break;
    case 5: 
      var $16=HEAP32[((((__Py_NoneStruct)|0))>>2)];
      var $17=((($16)+(1))|0);
      HEAP32[((((__Py_NoneStruct)|0))>>2)]=$17;
      $1=__Py_NoneStruct;
      label = 6; break;
    case 6: 
      var $19=$1;
      STACKTOP = __stackBase__;
      return $19;
    default: assert(0, "bad label: " + label);
  }
}
function _op_lt($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str191)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyObject_RichCompare($9, $10, 0);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_le($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str190)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyObject_RichCompare($9, $10, 1);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_eq($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str189)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyObject_RichCompare($9, $10, 2);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_ne($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str188)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyObject_RichCompare($9, $10, 3);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_gt($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str187)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyObject_RichCompare($9, $10, 4);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_ge($s, $a) {
  var label = 0;
  var __stackBase__  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; assert(!(STACKTOP&3)); assert((STACKTOP|0) < (STACK_MAX|0));
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      var $a1=__stackBase__;
      var $a2=(__stackBase__)+(4);
      $2=$s;
      $3=$a;
      var $4=$3;
      var $5=_PyArg_UnpackTuple($4, ((__str186)|0), 2, 2, (tempInt=STACKTOP,STACKTOP = (STACKTOP + 8)|0,assert((STACKTOP|0) < (STACK_MAX|0)),HEAP32[((tempInt)>>2)]=$a1,HEAP32[(((tempInt)+(4))>>2)]=$a2,tempInt));
      var $6=(($5)|(0))!=0;
      if ($6) { label = 3; break; } else { label = 2; break; }
    case 2: 
      $1=0;
      label = 4; break;
    case 3: 
      var $9=HEAP32[(($a1)>>2)];
      var $10=HEAP32[(($a2)>>2)];
      var $11=_PyObject_RichCompare($9, $10, 5);
      $1=$11;
      label = 4; break;
    case 4: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + label);
  }
}
function _op_sequenceIncludes($seq, $ob) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      var $3;
      $2=$seq;
      $3=$ob;
      var $4=HEAP32[((_Py_Py3kWarningFlag)>>2)];
      var $5=(($4)|(0))!=0;
      if ($5) { label = 2; break; } else { label = 3; break; }
    case 2: 
      var $7=HEAP32[((_PyExc_DeprecationWarning)>>2)];
      var $8=_PyErr_WarnEx($7, ((__str226)|0), 1);
      var $11 = $8;label = 4; break;
    case 3: 
      var $11 = 0;label = 4; break;
    case 4: 
      var $11;
      var $12=(($11)|(0)) < 0;
      if ($12) { label = 5; break; } else { label = 6; break; }
    case 5: 
      $1=-1;
      label = 7; break;
    case 6: 
      var $15=$2;
      var $16=$3;
      var $17=_PySequence_Contains($15, $16);
      $1=$17;
      label = 7; break;
    case 7: 
      var $19=$1;
      return $19;
    default: assert(0, "bad label: " + label);
  }
}
function _op_isCallable($x) {
  var label = 0;
  label = 1; 
  while(1) switch(label) {
    case 1: 
      var $1;
      var $2;
      $2=$x;
      var $3=HEAP32[((_Py_Py3kWarningFlag)>>2)];
      var $4=(($3)|(0))!=0;
      if ($4) { label = 2; break; } else { label = 3; break; }
    case 2: 
      var $6=HEAP32[((_PyExc_DeprecationWarning)>>2)];
      var $7=_PyErr_WarnEx($6, ((__str228)|0), 1);
      var $10 = $7;label = 4; break;
    case 3: 
      var $10 = 0;label = 4; break;
    case 4: 
      var $10;
      var $11=(($10)|(0)) < 0;
      if ($11) { label = 5; break; } else { label = 6; break; }
    case 5: 
      $1=-1;
      label = 7; break;
    case 6: 
      var $14=$2;
      var $15=_PyCallable_Check($14);
      $1=$15;
      label = 7; break;
    case 7: 
      var $17=$1;
      return $17;
    default: assert(0, "bad label: " + label);
  }
}
// EMSCRIPTEN_END_FUNCS
// EMSCRIPTEN_END_FUNCS
// Warning: printing of i64 values may be slightly rounded! No deep i64 math used, so precise i64 code not included
var i64Math = null;
// === Auto-generated postamble setup entry stuff ===
function run(args) {
  initRuntime();
}
Module['run'] = run;
// {{PRE_RUN_ADDITIONS}}
run();
// {{POST_RUN_ADDITIONS}}
  // {{MODULE_ADDITIONS}}
  return Module;
});
